---
title: "Lecture 04: Recursion III"
layout: reveal
---
{::options syntax_highlighter="nil" /}

# Lecture 04: Recursion III

## Outline

1. Tower of Hanoi
    - recursive strategy
	- in code
2. Concluding Thoughts on Recursion
3. Preview: Defining New Objects

## Last Time: Tower of Hanoi

## Setup

![](/assets/img/hanoi/initial.png){: width="100%"}

## Goal

![](/assets/img/hanoi/goal.png){: width="100%"}

## Rules

![](/assets/img/hanoi/first-move.png){: width="45%"}
![](/assets/img/hanoi/illegal.png){: width="45%"}

## A Program

Want:

- A program that generates instructions for a solution
- Example solution for 2 disks

```text
Move disk from peg 1 to peg 2
Move disk from peg 1 to peg 3
Move disk from peg 2 to peg 3
```

## Solution for 3 Disks?

<div style="margin-bottom: 12em"></div>

## Moving the Largest Disk

How to move largest disk from peg 1 to peg 3?

<div style="margin-bottom: 12em"></div>

## Solving in 3 Steps (1)

Step 1: Move subtower to peg 2

![](/assets/img/hanoi/step-1.png){: width="100%"}

## Solving in 3 Steps (2)

Step 2: Move bottom disk to peg 3

![](/assets/img/hanoi/step-2.png){: width="100%"}

## Solving in 3 Steps (3)

Step 3: Move subtower to peg 3

![](/assets/img/hanoi/step-3.png){: width="100%"}


## Moving a Sub-Tower

How do we move $$m $$ disks from peg $$i $$ to peg $$j $$?

<div style="margin-bottom: 12em"></div>


## A General Procedure

To move $$m $$ disks from peg $$i $$ to $$j $$:

1. move $$m - 1$$ disks from $$i $$ to $$k $$ (other peg)
2. move one disk from $$i $$ to $$j $$
3. move $$m - 1$$ disks from $$k $$ to $$j $$

What is missing?

## Base Case!

If $$m = 1$$, just print

```text
Move disk from peg i to peg j
```

## Let's try it in code!

[TowerOfHanoi.java]()

## How Efficient is our Solution?

```java
void move (int m, int from, int to, int other) {
    if (m == 1) {
        System.out.println("Move disk from " + from + " to " + to);
        return;
    }
	
	move(m - 1, from, other, to);
	move(1, from, to, other);
	move(m - 1, other, to, from);		
}
```

<div style="margin-bottom: 12em"></div>




## Counting Recursive Calls

If $$f(m )$$ is number of instructions printed to move $$m $$ disks:

- $$f(m) = 2 \cdot f(m-1) + f(1)$$, and $$f(1) = 1$$
- So we get:
    + $f(1) = 1$
	+ $f(2) = 2 \cdot f(1) + 1 = 3$
	+ $f(3) = 2 \cdot f(2) + 1 = 7$
	+ $\vdots$
	+ $f(m) = 2^m - 1$
	
- This is a lot of instructions!
    + $f(10) \approx 1,000$, $f(20) \approx 1,000,000$, $f(30) \approx 1,000,000,000$
	
## But...

Solving Tower of Hanoi with $m$ disks *requires* $2^m - 1$ instructions!

- The solution generated by our program is optimal
- Requires only 5 lines of code!

# Concluding Thoughts on Recursion

## Factorial

```java
private static int factorial(int n) {
    if (n == 1) return 1;
    return n * factorial(n - 1);
}
```

## Fibonacci

```java
private static int fibonacci (int n) {
    if (n <= 2) return 1;
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```

## Tower of Hanoi

```java
private static void move (int num, int from, int to, int other) {
    if (num == 1) {
        System.out.println("Move disk from " + from + " to " + to + "." );
        return;
    }
    move(num - 1, from, other, to);
    move(1, from, to, other);
    move(num - 1, other, to, from);
}
```

## Evaluation

1. Factorial: simple code and efficient execution
2. Fibonacci: simple code, but inefficient execution
3. ToH: surprisingly simple; perhaps mysterious; large solution
    - but solution is still optimal

## Moral

Recursion is...

- subtle
- sometimes efficient, sometimes not
- powerful
- miraculous
- confusing

## How Confusing?

```java
public static long collatz (long n) {
    if (n == 1) return 1;
    if (n % 2 == 0) return collatz (n / 2);
    else return collatz (3 * n + 1);
}
```

<div style="margin-bottom: 12em"></div>

## Insanity

```java
public static long collatz (long n) {
    if (n == 1) return 1;
    if (n % 2 == 0) return collatz (n / 2);
    else return collatz (3 * n + 1);
}
```

- **It is not known if this method has an infinite loop for some value of `n`**
- This is not for lack of interest in the problem:
    + Worked on by some of the most celebrated mathematicians of the last century


# Up Next: Defining New Objects

<!-- ## Coding So Far -->

<!-- 1. Statements, blocks, control flow (conditionals and iteration) -->
<!-- 2. Methods: **procedural programming** -->
<!--     + encapsulate code in methods -->
<!-- 	+ methods recieve input (arguments), perform operations, (maybe) produduce output (`return`) -->
<!-- 	+ when a method returns, all its resources (local variables) go away -->
	

<!-- ## Procedural Programming -->

<!-- Design Principle: -->

<!-- - Break a large task into smaller sub-tasks -->
<!--     + write a method for each sub-task -->
	
<!-- - Makes code better: -->
<!--     + shows *intent* -->
<!-- 	+ easier to maintain (one error, one bug) -->
<!-- 	+ makes code easier to read/understand -->
	
<!-- Methods allow for **encapsulation**: write a single piece of code that can be used by many parts of a program. -->

	
<!-- ## Object Orientation -->

<!-- Idea: encapsulate code in **objects** -->

<!-- 1. Create object **instances** -->
<!--     + each instance is like its own program -->
<!-- 2. Instances are **persistent** -->
<!--     + once an instance is created, it remains indefinitely -->
<!-- 3. Instances have internal **state** -->
<!--     + *instance variables*  -->
<!-- 4. Instances can change internal state -->
<!--     + *instance methods* are specific to each instance -->
<!-- 5. Instances can interact -->
<!--     + call methods on an instance  -->
	
<!-- ## Object Oriented Design -->

<!-- A different way to conceptualize a program: -->

<!-- - Think in terms of interacting objects -->

<!-- Advantages: -->

<!-- - More conceptual structure -->
<!-- - Better encapsulation -->
<!-- - Separate **interface** from **implementation** -->
<!--     + don't need to understand how an object works (internally) to use the object -->
	
	
<!-- ## An Object -->

<!-- Forget about programming for a moment -->

<!-- <iframe width="560" height="315" src="https://www.youtube.com/embed/RyCnHyUKt5M" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe> -->

<!-- ## Describe the Object -->

<!-- ## What is it? -->

<!-- <div style="margin-bottom: 12em"></div> -->


<!-- ## How do You *Interact* With it? -->

<!-- <div style="margin-bottom: 12em"></div> -->

<!-- ## What Functionality Does it Offer? -->

<!-- <div style="margin-bottom: 12em"></div> -->

<!-- ## What is its Internal State? -->

<!-- <div style="margin-bottom: 12em"></div> -->

<!-- ## What *Limitations* Does it Have? -->

<!-- <div style="margin-bottom: 12em"></div> -->

<!-- ## How Can We Represent it in Code? -->

<!-- We will define a `Counter` object! -->

<!-- - Internal state: -->
<!--     + store count as an `int` -->
	
<!-- - Instance methods: -->
<!--     + get count -->
<!-- 	+ increment counter -->
<!-- 	+ reset -->
	
<!-- - Constructor -->

<!-- Code it together! -->
	
<!-- ## The Completed Object -->

<!-- ```java -->
<!-- public class Counter { -->
<!--     private int count; -->
    
<!-- 	// constructor defines how to initialize instance -->
<!--     public Counter () { -->
<!-- 	    count = 0; -->
<!-- 	} -->
	
<!-- 	// getter method for count -->
<!-- 	public int getCount () { -->
<!-- 	    return count; -->
<!-- 	} -->
	
<!-- 	// increment the counter -->
<!-- 	public void increment () { -->
<!-- 	    count++; -->
<!-- 	} -->
	
<!-- 	// reset the counter -->
<!-- 	public void reset () { -->
<!-- 	    count = 0; -->
<!-- 	} -->
<!-- } -->
<!-- ``` -->

<!-- ## sdf -->
