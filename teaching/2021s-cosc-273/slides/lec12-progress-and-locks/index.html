<!doctype html>
<html lang="en">
	<head>

	  <meta name="viewport" content="width=device-width, initial-scale=1.0">
	  <meta charset="utf-8">

		<link rel="stylesheet" href="/assets/reveal.js-master/dist/reset.css">
		<link rel="stylesheet" href="/assets/reveal.js-master/dist/reveal.css">
		<link rel="stylesheet" href="/assets/css/condensation.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="/assets/reveal.js-master/plugin/highlight/monokai.css" id="highlight-theme">
		<link href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700" rel="stylesheet">

	</head>

	<body>


	  <!-- this is where the reveailfy filter gets applied -->
	  <div class="reveal"><div class="slides">
























































































































































































































































<section id="lecture-12-progress-and-lock-implementations"><h1>Lecture 12: Progress and Lock Implementations</h1></section><section id="overview"><h2>Overview</h2>
<ol>
  <li>Non-blocking progress
    <ul>
      <li>Wait-freedom</li>
      <li>Lock-freedom</li>
    </ul>
  </li>
  <li>Blocking vs Non-blocking Progress</li>
  <li>Lock Implementations</li>
</ol></section><section id="last-time"><h2>Last Time</h2>
<p>Progress Conditions:</p>
<ul>
  <li>
    <p><strong>Wait-freedom</strong>: pending method invocation always completes in a finite number of steps</p>
  </li>
  <li>
    <p><strong>Lock-freedom</strong>: among all pending method calls, some method completes in a finite number of steps</p>
  </li>
</ul>
<p>Observed: wait-free $\implies$ lock-free</p></section><section id="a-wait-free-counter"><h2>A Wait-free Counter</h2>
<pre><code class="language-java">public class TwoCounter {
    int[] counts = new int[2];
	
    public void increment (int amt) {
        int i = ThreadID.get(); // thread IDs are 0 and 1
        int count = counts[i];
        counts[i] = count + amt;
    }
	
    public int read () {
        int count = counts[0];
        count = count + counts[1];
        return count;
    }
}
</code></pre></section><section id="an-atomic-primitive"><h2>An Atomic Primitive</h2>
<p><code>AtomicInteger</code> class:</p>
<pre><code class="language-java">boolean compareAndSet(int expectedValue, int newValue); // ATOMIC
</code></pre>
<p>Specification for <code>AtomicInt ai</code>:</p>
<ul>
  <li>if <code>ai</code>’s value is <code>expectedValue</code>, then
    <ul>
      <li>after call, <code>ai</code>’s value is <code>newValue</code>
</li>
      <li>method returns <code>true</code>
</li>
    </ul>
  </li>
  <li>if <code>ai</code>’s value is not <code>expectedValue</code>, then
    <ul>
      <li>after call, <code>ai</code>’s value is unchanged</li>
      <li>method returns <code>false</code>
</li>
    </ul>
  </li>
</ul></section><section id="a-silly-counter"><h2>A Silly Counter</h2>
<pre><code class="language-java">public class SillyCounter {

    AtomicInteger ai = new AtomicInteger(0);
	
    public void increment (int amt) {
        int val = ai.get();
        while (!ai.compareAndSet(val, val + amt)) {
            val = ai.get();
        }
    }
	
    public int read () {
        return ai.get();
    }
	
}
</code></pre></section><section id="does-sillycounter-work"><h2>Does <code>SillyCounter</code> Work?</h2>
<pre><code class="language-java">public class SillyCounter {

    AtomicInteger ai = new AtomicInteger(0);
	
    public void increment (int amt) {
        int val = ai.get();
        while (!ai.compareAndSet(val, val + amt)) {
            val = ai.get();
        }
    }
	
    public int read () {
        return ai.get();
    }
	
}
</code></pre>
<div style="margin-bottom: 8em"></div></section><section id="is-sillycounter-lock-free"><h2>Is <code>SillyCounter</code> Lock-free?</h2>
<pre><code class="language-java">    public void increment (int amt) {
        int val = ai.get();
        while (!ai.compareAndSet(val, val + amt)) {
            val = ai.get();
        }
    }
</code></pre>
<div style="margin-bottom: 12em"></div></section><section id="is-sillycounter-wait-free"><h2>Is <code>SillyCounter</code> Wait-free?</h2>
<pre><code class="language-java">    public void increment (int amt) {
        int val = ai.get();
        while (!ai.compareAndSet(val, val + amt)) {
            val = ai.get();
        }
    }
</code></pre>
<div style="margin-bottom: 12em"></div></section><section id="properties-of-nonblocking-progress"><h2>Properties of Nonblocking Progress</h2>
<ul>
  <li>Progress is guaranteed even if some thread stalls
    <ul>
      <li>e.g., scheduler stops scheduling a thread’s method call</li>
    </ul>
  </li>
  <li>Wait-freedom gives <em>maximal progress</em>
</li>
  <li>Lock-freedom gives <em>minimal progress</em>
    <ul>
      <li>starvation can still occur</li>
    </ul>
  </li>
  <li>Actual progress depends on <em>scheduler</em>
    <ul>
      <li>determines which threads make steps</li>
    </ul>
  </li>
</ul>
<div style="margin-bottom: 4em"></div></section><section id="blocking-progress-conditions"><h2>Blocking Progress Conditions</h2>
<ul>
  <li>
<strong>starvation-free</strong>: whenever <em>all</em> pending methods take steps, <em>every</em> method call completes in a finite number of steps
    <ul>
      <li>maximal (blocking) progress</li>
    </ul>
  </li>
</ul>
<div style="margin-bottom: 4em"></div>
<ul>
  <li>
<strong>deadlock-free</strong>: whenever <em>all</em> pending method calls take steps, <em>some</em> method call completes in a finite number of steps
    <ul>
      <li>minimal (blocking) progress</li>
    </ul>
  </li>
</ul>
<div style="margin-bottom: 4em"></div></section><section id="blocking-vs-nonblocking-progess"><h2>Blocking vs Nonblocking Progess</h2>
<p>Nonblocking progress</p>
<ul>
  <li>guarantees progress for <em>any</em> scheduler</li>
  <li>valid even if a process crashes</li>
</ul>
<div style="margin-bottom: 4em"></div>
<p>Blocking progress</p>
<ul>
  <li>progress only guaranteed for <em>fair</em> schedulers</li>
  <li>if a process crashes, progress not guaranteed</li>
</ul>
<div style="margin-bottom: 4em"></div></section><section id="which-is-better"><h2>Which is Better?</h2>
<pre><code class="language-java">public class SillyCounter {
    private AtomicInteger ai = new AtomicInteger(0);
    public void increment (int amt) {
        int val = ai.get();
        while (!ai.compareAndSet(val, val + amt)) {
            val = ai.get();
        }
    }
}
</code></pre>
<p>Or</p>
<pre><code class="language-java">public class LockedCounter {
    private Lock lock = new StarvationFreeLock();
    int count = 0;
    public void increment (int amt) {
        lock.lock()
        try {
            count += amt;
        } finally {
            lock.unlock();
        }
    }
}
</code></pre></section><section id="scheduling-w-2-threads"><h2>Scheduling w/ 2 Threads</h2>
<pre><code class="language-java">public class SillyCounter {
    private AtomicInteger ai = new AtomicInteger(0);
    public void increment (int amt) {
        int val = ai.get();
        while (!ai.compareAndSet(val, val + amt)) {
            val = ai.get();
        }
    }
}
</code></pre>
<p>What happens to thread 1 if scheduler stops scheduling steps of thread 2?</p>
<div style="margin-bottom: 6em"></div></section><section id="scheduling-w-2-threads-1"><h2>Scheduling w/ 2 Threads</h2>
<pre><code class="language-java">public class LockedCounter {
    private Lock lock = new StarvationFreeLock();
    int count = 0;
    public void increment (int amt) {
        lock.lock()
        try {
            count += amt;
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>
<p>What happens to thread 1 if scheduler stops scheduling steps of thread 2?</p>
<div style="margin-bottom: 6em"></div></section><section id="scheduling-w-2-threads-2"><h2>Scheduling w/ 2 Threads</h2>
<pre><code class="language-java">public class SillyCounter {
    private AtomicInteger ai = new AtomicInteger(0);
    public void increment (int amt) {
        int val = ai.get();
        while (!ai.compareAndSet(val, val + amt)) {
            val = ai.get();
        }
    }
}
</code></pre>
<p>Is thread 1 guaranteed to make progress under <em>fair</em> scheduler?</p>
<div style="margin-bottom: 6em"></div></section><section id="scheduling-w-2-threads-3"><h2>Scheduling w/ 2 Threads</h2>
<pre><code class="language-java">public class LockedCounter {
    private Lock lock = new StarvationFreeLock();
    int count = 0;
    public void increment (int amt) {
        lock.lock()
        try {
            count += amt;
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>
<p>Is thread 1 guaranteed to make progress under <em>fair</em> scheduler?</p>
<div style="margin-bottom: 6em"></div></section><section id="so"><h2>So</h2>
<ul>
  <li>With an unfair scheduler (or when threads can be interrupted), lock-freedom (nonblocking) might be better
    <ul>
      <li>guarantees some progress</li>
    </ul>
  </li>
  <li>With a fair scheduler (threads will not be interrupted), starvation-freedom (blocking) might be better
    <ul>
      <li>with fairness assumption, <em>every</em> thread is guaranteed progress</li>
    </ul>
  </li>
</ul>
<p>Nonblocking is not strictly superior to blocking!</p></section><section id="progress-vs-correctness"><h2>Progress vs Correctness</h2>
<ul>
  <li>Can have a data structure that is…
    <ul>
      <li>…sequentially consistent and wait-free</li>
      <li>…linearizable and lock-free</li>
      <li>…sequentially consistent and deadlock-free</li>
      <li>…</li>
    </ul>
  </li>
  <li>
    <p>Different implementations have different trade-offs</p>
  </li>
  <li>Which implementation is best depends on application:
    <ul>
      <li>how much synchronization is required?
        <ul>
          <li>how frequently is contention expected?</li>
        </ul>
      </li>
      <li>what correctness guarantee is required?</li>
    </ul>
  </li>
</ul></section><section id="finally-implementations"><h1>Finally: Implementations</h1></section><section id="back-to-where-we-started"><h2>Back to Where We Started</h2>
<ol>
  <li>A <code>Counter</code> object, now with a lock</li>
  <li>A lock</li>
</ol></section><section id="lets-implement-a-lock"><h2>Let’s Implement a Lock!</h2>
<p>Recall the Peterson lock:</p>
<pre><code class="language-java">class Peterson implements Lock {
    private boolean[] flag = new boolean[2];
    private int victim;
	
    public void lock () {
       int i = ThreadID.get(); // get my ID, 0 or 1
       int j = 1 - i;          // other thread's ID
	   
       flag[i] = true;         // set my flag
       victim = i;             // set myself to be victim
       while (flag[j] &amp;&amp; victim == i) {};
    }
	
    public void unlock () {
        int i = ThreadID.get();
        flag[i] = false;
    }
}
</code></pre></section><section id="a-challenge"><h2>A Challenge</h2>
<p>Peterson lock assumes 2 threads, with IDs <code>0</code> and <code>1</code></p>
<ul>
  <li>How do we accomplish this?</li>
</ul>
<div style="margin-bottom: 8em"></div></section><section id="make-a-thread-subclass"><h2>Make a Thread Subclass</h2>
<p>Manually set an ID for threads</p>
<pre><code class="language-java">public class PetersonThread extends Thread {
    private int id;
    private LockedCounter ctr;
    private int numIncrements;

    public PetersonThread (int id, LockedCounter ctr, int numIncrements) {
	super();
	this.id = id;
	this.ctr = ctr;
	this.numIncrements = numIncrements;
    }

    public int getPetersonId() {
	return id;
    }

    @Override
    public void run () {
	for (int i = 0; i &lt; numIncrements; ++i) {
	    ctr.increment();
	}
    }
}
</code></pre></section><section id="making-a-petersonlock"><h2>Making a <code>PetersonLock</code>
</h2>
<pre><code class="language-java">class PetersonLock {
    private boolean[] flag = new boolean[2];
    private int victim;

    public void lock () {
	int i = ((PetersonThread)Thread.currentThread()).getPetersonId();
	int j = 1 - i;
	flag[i] = true;
	victim = i;
	while (flag[j] &amp;&amp; victim == i) {};
    }

    public void unlock () {
	int i = ((PetersonThread)Thread.currentThread()).getPetersonId();	
	flag[i] = false;
    }
}
</code></pre></section><section id="and-now-a-locked-counter"><h2>And Now: A Locked Counter</h2>
<pre><code class="language-java">public class LockedCounter {
    private int count = 0;
    PetersonLock lock = new PetersonLock();

    public void increment () {
	lock.lock();
	try {
	    ++count;
	} finally {
	    lock.unlock();
	}
    }

    public int read () {
	return count;
    }
}
</code></pre></section><section id="finally-were-ready-to-test-it"><h2>Finally, We’re Ready to Test It!</h2></section><section id="doh"><h2>D’oh!</h2>
<p>What happened?</p>
<div style="margin-bottom: 8em"></div></section><section id="memory-consistency"><h2>Memory Consistency!</h2>
<p><img src="/assets/img/cache-hierarchy/cache-cpu.png" alt="" width="75%"></p></section><section id="volatile-variables"><h2>
<code>volatile</code> Variables</h2>
<p>Java can make variables visible between threads:</p>
<ul>
  <li>use <code>volatile</code> keyword</li>
  <li>individual read/write operations to <code>volatile</code> are atomic</li>
</ul>
<p>Drawbacks:</p>
<ul>
  <li>
<code>volatile</code> variables are less efficient</li>
  <li>
<em>only</em> single read/write operations are atomic
    <ul>
      <li>e.g. <code>count++</code> not atomic</li>
    </ul>
  </li>
</ul></section><section id="what-variables-should-be-volatile"><h2>What Variables Should be <code>volatile</code>?</h2>
<ul>
  <li>In <code>PetersonLock</code>?</li>
  <li>In <code>LockedCounter</code>?</li>
</ul></section><section id="petersonlock-again"><h2>
<code>PetersonLock</code> Again</h2>
<pre><code class="language-java">class PetersonLock {
    private boolean[] flag = new boolean[2];
    private int victim;

    public void lock () {
	int i = ((PetersonThread)Thread.currentThread()).getPetersonId();
	int j = 1 - i;
	flag[i] = true;
	victim = i;
	while (flag[j] &amp;&amp; victim == i) {};
    }

    public void unlock () {
	int i = ((PetersonThread)Thread.currentThread()).getPetersonId();	
	flag[i] = false;
    }
}
</code></pre></section><section id="a-problem"><h2>A Problem</h2>
<p>Only primitive datatypes can be <code>volatile</code></p>
<ul>
  <li>
<code>volatile boolean[] flag</code> makes the <em>reference</em> <code>volatile</code>, not the data itself</li>
</ul>
<p>How to fix this?</p>
<div style="margin-bottom: 8em"></div></section><section id="a-fix"><h2>A Fix</h2>
<p>Just make 2 <code>boolean</code> variables, <code>flag0</code> and <code>flag1</code></p>
<ul>
  <li>Yes, I know this is ugly</li>
</ul></section><section id="lockedcounter-again"><h2>
<code>LockedCounter</code> Again</h2>
<pre><code class="language-java">public class LockedCounter {
    private int count = 0;
    PetersonLock lock = new PetersonLock();

    public void increment () {
	lock.lock();
	try {
	    ++count;
	} finally {
	    lock.unlock();
	}
    }

    public int read () {
	return count;
    }
}
</code></pre></section><section id="testing-our-counter-again"><h2>Testing Our Counter Again</h2></section><section id="finally"><h2>Finally!!!</h2>
<p>What have we done?</p>
<ol>
  <li>
<em>Proven</em> correctness of a lock
    <ul>
      <li>idealized model of computation</li>
      <li>atomic read/write operations</li>
    </ul>
  </li>
  <li>Implemented lock
    <ul>
      <li>used Java to resemble idealized model</li>
    </ul>
  </li>
  <li>Used lock
    <ul>
      <li>saw expected behavior</li>
    </ul>
  </li>
</ol>
<p>Theory and practice converge!</p></section><section id="limitations"><h2>Limitations</h2>
<ul>
  <li>Limitations of <code>PetersonLock</code>
    <ul>
      <li>only two threads</li>
      <li>weird Java gymnastics to deal with thread IDs</li>
    </ul>
  </li>
  <li>Limitations of <code>volatile</code> variables
    <ul>
      <li>can ony perform atomic read/write operations</li>
      <li>only for primitive data-types</li>
      <li>need at least <code>n</code> registers (variables) for lock with <code>n</code> threads</li>
    </ul>
  </li>
</ul></section><section id="simplicity-through-atomicity"><h2>Simplicity through Atomicity</h2>
<p>Better locks through atomics:</p>
<ul>
  <li>
<code>AtomicBoolean</code> supports atomic operations in addition to</li>
  <li>For example:
    <ul>
      <li><code>ab.getAndSet(boolean newValue)</code></li>
      <li>sets <code>ab</code>’s value to <code>newValue</code> and returns previous value</li>
    </ul>
  </li>
</ul>
<p>How could you use a single <code>AtomicBoolean</code></p></section><section id="the-test-and-set-lock"><h2>The Test-and-set Lock</h2>
<pre><code class="language-java">public class TASLock {
    AtomicBoolean isLocked = new AtomicBoolean(false);
	
    public void lock () {
        while (isLocked.getAndSet(true)) {}
    }
	
	public void unlock () {
        isLocked.set(false);
	}
}
</code></pre></section><section id="advantagesdisadvantages"><h2>Advantages/Disadvantages?</h2>
<pre><code class="language-java">public class TASLock {
    AtomicBoolean isLocked = new AtomicBoolean(false);
	
    public void lock () {
        while (isLocked.getAndSet(true)) {}
    }
	
	public void unlock () {
        isLocked.set(false);
	}
}
</code></pre>
<div style="margin-bottom: 8em"></div></section><section id="next-time"><h2>Next Time</h2>
<ul>
  <li>More Locks!</li>
</ul></section>
</div></div>


	  <script src="/assets/reveal.js-master/dist/reveal.js"></script>
	  <script src="/assets/reveal.js-master/plugin/math/math.js"></script>
	  <script src="/assets/reveal.js-master/plugin/zoom/zoom.js"></script>
	  <script src="/assets/reveal.js-master/plugin/notes/notes.js"></script>
	  <script src="/assets/reveal.js-master/plugin/search/search.js"></script>
	  <script src="/assets/reveal.js-master/plugin/markdown/markdown.js"></script>
	  <script src="/assets/reveal.js-master/plugin/highlight/highlight.js"></script>
	  <script>
	    

	    // Also available as an ES module, see:
	    // https://revealjs.com/initialization/
	    Reveal.initialize({
		controls: false,
		progress: true,
		center: true,
		hash: true,
		transition: 'none',
		math: {
		    config: 'TeX-AMS_HTML-full',
		    TeX: {
			Macros: {
			    R: '\\mathbb{R}',
			    set: [ '\\left\\{#1 \\; ; \\; #2\\right\\}', 2 ]
			}
		    }
		},


		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight, RevealMath ]
	    });

	  </script>

	</body>
</html>
	  

<!-- <\!-- load the reveal.js css & js (assuming you've put it in assets/)-\-> -->
<!-- <link -->
<!--   rel="stylesheet" -->
<!--   href="/assets/reveal.js-master/css/reveal.scss" -->
<!-- /> -->
<!-- <link -->
<!--   rel="stylesheet" -->
<!--   href="/assets/reveal.js-master/css/theme/source/white.scss" -->
<!-- /> -->
<!-- <script -->
<!--   src="/assets/reveal.js-master/js/reveal.js" -->
<!--   type="text/javascript" -->
<!-- ></script> -->

<!-- <\!-- configure the presentation, (you can tweak options to suit) -\-> -->
<!-- <script> -->
<!--   Reveal.initialize({ -->
<!--     // Display presentation control arrows -->
<!--     controls: false, -->

<!--     // Help the user learn the controls by providing hints, for example by -->
<!--     // bouncing the down arrow when they first encounter a vertical slide -->
<!--     controlsTutorial: false, -->

<!--     // Determines where controls appear, "edges" or "bottom-right" -->
<!--     controlsLayout: "bottom-right", -->

<!--     // Visibility rule for backwards navigation arrows; "faded", "hidden" -->
<!--     // or "visible" -->
<!--     controlsBackArrows: "faded", -->

<!--     // Display a presentation progress bar -->
<!--     progress: true, -->

<!--     // Display the page number of the current slide -->
<!--     slideNumber: false, -->

<!--     // Push each slide change to the browser history -->
<!--     history: false, -->

<!--     // Enable keyboard shortcuts for navigation -->
<!--     keyboard: true, -->

<!--     // Enable the slide overview mode -->
<!--     overview: true -->
<!--   }); -->
<!-- </script> -->
