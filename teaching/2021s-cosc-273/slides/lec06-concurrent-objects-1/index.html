<!doctype html>
<html lang="en">
	<head>

	  <meta name="viewport" content="width=device-width, initial-scale=1.0">
	  <meta charset="utf-8">

		<link rel="stylesheet" href="/assets/reveal.js-master/dist/reset.css">
		<link rel="stylesheet" href="/assets/reveal.js-master/dist/reveal.css">
		<link rel="stylesheet" href="/assets/css/condensation.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="/assets/reveal.js-master/plugin/highlight/monokai.css" id="highlight-theme">
		<link href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700" rel="stylesheet">

	</head>

	<body>


	  <!-- this is where the reveailfy filter gets applied -->
	  <div class="reveal"><div class="slides">


















































































































































































































<!-- ## For Your Consideration -->

<!-- What happens if we allow node removal as well? What could go wrong? -->

<!-- <div style="margin-bottom: 12em"></div> -->

<!-- ## A Slightly Different Scenario -->

<!-- ![](/assets/img/concurrent-objects/CircularList.png){: width="50%"} -->

<!-- ## Question -->

<!-- Are multiple concurrent insertions guaranteed to eventually succeed? -->

<!-- ![](/assets/img/concurrent-objects/CircularList.png){: width="25%"} -->

<!-- <div style="margin-bottom: 8em"></div> -->

<!-- ## Another Question -->

<!-- Can this problem occur if list is not circular? -->

<!-- ```java -->
<!--     public void insert (Node nd, value) { -->
<!--         Node cur = new Node(value); -->

<!--         nd.lock(); -->
<!--         try { -->
<!--             Node next = nd.getNext(); -->
<!--             if (next != null) next.lock(); -->
<!--             nd.next = cur; -->
<!--             cur.prev = nd; -->
<!--             cur.next = next; -->
<!--             if (next != null) next.prev = cur; -->
<!--         } finally { -->
<!--             if (next != null) next.unlock(); -->
<!--             nd.unlock(); -->
<!--         } -->
<!--     } -->
<!-- ``` -->

<!-- <div style="margin-bottom: 4em"></div> -->

<!-- ## Morals -->

<!-- 1. Fine-grained locking is desireable -->
<!--     - some operations can be performed in parallel -->
<!-- 	- get more efficiency -->
<!-- 2. Fine-grained locking is subtle -->
<!-- 	- reasoning about multiple locks is delicate -->
<!--     - can achieve deadlock, even when no individual lock does! -->

<!-- Need to formalize what we *want* to achieve with concurrent access -->

<!-- ## Next Week -->

<!-- Formalizing what we want to achieve with concurrent -->

<!-- - Understanding what is (im)possible with concurrent objects -->
<!-- - Want best tradeoff between performance and correctness -->

<section id="lecture-06-concurrent-objects-1"><h1>Lecture 06: Concurrent Objects 1</h1></section><section id="outline"><h2>Outline</h2>
<ol>
  <li>Finishing Up Mutex:
    <ul>
      <li>Bakery Algorithm</li>
      <li>Lower Bounds</li>
    </ul>
  </li>
  <li>Concurrent Objects</li>
</ol></section><section id="last-time"><h2>Last Time</h2>
<p>Lamport’s Bakery Algorithm</p>
<pre><code class="language-java">public void lock () {
    int i = ThreadID.get();
    flag[i] = true;
    label[i] = max(label[0], ..., label[n-1]) + 1;
    while (!hasPriority(i)) {} // wait	
}

public void unlock() {
    flag[ThreadID.get()] = false;
}
</code></pre></section><section id="we-showed"><h2>We Showed:</h2>
<ol>
  <li>Deadlock-freedom
    <ul>
      <li>unique thread with highest priority obtains lock</li>
    </ul>
  </li>
  <li>First-come-first-served (FCFS) Property
    <ul>
      <li>if <code>i</code> writes <code>label[i]</code> before <code>j</code> writes <code>label[j]</code>, then <code>i</code> obtains lock before <code>j</code>
</li>
    </ul>
  </li>
</ol>
<p>Starvation-freedom follows from 1 and 2</p></section><section id="to-show-mutual-exclusion"><h2>To Show: Mutual Exclusion</h2>
<pre><code class="language-java">public void lock () {
    int i = ThreadID.get();
    flag[i] = true;
    label[i] = max(label[0], ..., label[n-1]) + 1;
    while (!hasPriority(i)) {} // wait	
}
</code></pre>
<p>Suppose not:</p>
<ul>
  <li>$A$ and $B$ concurrently in CS</li>
  <li>Assume: $(\mathrm{label}(A), A) &lt; (\mathrm{label}(B), B)$</li>
</ul></section><section id="proof-continued"><h2>Proof (Continued)</h2>
<p>Since $B$ entered CS:</p>
<ul>
  <li>Must have read
    <ul>
      <li>$(\mathrm{label}(B), B) &lt; (\mathrm{label}(A), A)$, or</li>
      <li>$\mathrm{flag}[A] == \mathrm{false}$</li>
    </ul>
  </li>
  <li>
    <p>Former can not happen: labels strictly increasing</p>
  </li>
  <li>So $B$ read $\mathrm{flag}[A] == \mathrm{false}$</li>
</ul></section><section id="compare-timelines"><h2>Compare Timelines!</h2>
<div style="margin-bottom: 18em"></div></section><section id="conclusion"><h2>Conclusion</h2>
<p>Lamport’s Bakery Algorithm:</p>
<ol>
  <li>Works for any number of threads</li>
  <li>Satisfies MutEx and starvation-freedom</li>
</ol></section><section id="question"><h2>Question</h2>
<p>Is the bakery algorithm <em>practical?</em></p>
<ul>
  <li>Maybe for few threads…</li>
  <li>But for many threads?
    <ul>
      <li>
<code>label</code> array contains $n$ indices</li>
      <li>must read all entries to set own <code>label</code>
</li>
      <li>costly if many threads!</li>
    </ul>
  </li>
  <li>Could we do better?</li>
</ul></section><section id="remarkably"><h2>Remarkably</h2>
<p>We cannot do better:</p>
<ul>
  <li>
    <p>If $n$ threads want to achieve mutual exclusion + deadlock-freedom, must have $n$ read/write registers (variables)</p>
  </li>
  <li>This is really bad if we have a lot of threads!
    <ul>
      <li>1,000 threads means each call to <code>lock()</code> requires 1,000s of reads</li>
      <li>each call to <code>hasPriority</code> requires either 1,000 of reads or a more advanced data structure</li>
    </ul>
  </li>
  <li>Things are messy!</li>
</ul></section><section id="a-way-around-the-lower-bound"><h2>A Way Around the Lower Bound</h2>
<ul>
  <li>Argument relies crucially on fact that the <em>only</em> atomic operations are <code>read</code> and <code>write</code>
</li>
  <li>Modern computers offer more powerful atomic operations</li>
  <li>In Java, <code>AtomicBoolean</code> class offers, e.g.,
    <ul>
      <li><code>compareAndSet(boolean expectedValue, boolean newValue)</code></li>
      <li><code>getAndSet(boolean newValue)</code></li>
    </ul>
  </li>
  <li>These operations are useful, but still costly</li>
  <li>We will discuss more later</li>
</ul></section><section id="concurrent-objects"><h1>Concurrent Objects</h1></section><section id="so-far"><h2>So Far</h2>
<p>Considered mutual exclusion:</p>
<ul>
  <li>Restrict access to critical section of code to one thread at a time</li>
  <li>This makes sense for simple objects
    <ul>
      <li>e.g., the <code>increment()</code> method in <code>Counter</code>
</li>
    </ul>
  </li>
</ul>
<p>What about larger data structures?</p></section><section id="linked-lists"><h2>Linked Lists</h2>
<p>Recall: a (doubly) linked list</p>
<p><img src="/assets/img/concurrent-objects/OriginalList.png" alt="" width="100%"></p></section><section id="insertion-1"><h2>Insertion 1</h2>
<p><img src="/assets/img/concurrent-objects/SingleInsertion1.png" alt="" width="100%"></p></section><section id="insertion-2"><h2>Insertion 2</h2>
<p><img src="/assets/img/concurrent-objects/SingleInsertion2.png" alt="" width="100%"></p></section><section id="linked-list-in-code"><h2>Linked List in Code</h2>
<pre><code class="language-java">public class MyLinkedList {
    private Node head;
	...
	
    // insert a new node after nd
    public void insert (Node nd, value) {
        Node next = nd.getNext();
        Node cur = new Node(value);
        nd.next = cur;
        cur.prev = nd;
        cur.next = next;
        if (next != null) next.prev = cur;
    }
}

class Node {
    public Node next;
    public Node prev;
    public int value;
}
</code></pre></section><section id="insertion-with-multiple-threads"><h2>Insertion with Multiple Threads</h2>
<p>What could go wrong?</p>
<pre><code class="language-java">    public void insert (Node nd, value) {
        Node next = nd.getNext();
        Node cur = new Node(value);
        nd.next = cur;
        cur.prev = nd;
        cur.next = next;
        if (next != null) next.prev = cur;
    }
</code></pre>
<div style="margin-bottom: 8em"></div></section><section id="how-to-fix-the-problem"><h2>How to Fix The Problem?</h2>
<pre><code class="language-java">    public void insert (Node nd, value) {
        Node next = nd.getNext();
        Node cur = new Node(value);
        nd.next = cur;
        cur.prev = nd;
        cur.next = next;
        if (next != null) next.prev = cur;
    }
</code></pre>
<div style="margin-bottom: 12em"></div></section><section id="a-fix-locking-the-list"><h2>A Fix: Locking the List</h2>
<pre><code class="language-java">public class MyLinkedList {
    private Node head;
    private Lock lock;
	...
	
    // insert a new node after nd
    public void insert (Node nd, value) {
        lock.lock();
        try { // all of this is critical section
            Node next = nd.getNext();
            Node cur = new Node(value);
            nd.next = cur;
            cur.prev = nd;
            cur.next = next;
            if (next != null) next.prev = cur;
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>
<div style="margin-bottom: 8em"></div></section><section id="illustration-of-locked-execution"><h2>Illustration of Locked Execution</h2>
<p><img src="/assets/img/concurrent-objects/InsertBoth.png" alt="" width="100%"></p></section><section id="red-acquires-lock"><h2>Red Acquires Lock</h2>
<p><img src="/assets/img/concurrent-objects/RedBlocks.png" alt="" width="100%"></p></section><section id="red-inserts-element"><h2>Red Inserts Element</h2>
<p><img src="/assets/img/concurrent-objects/RedInserts.png" alt="" width="100%"></p></section><section id="red-releases-lock"><h2>Red Releases Lock</h2>
<p><img src="/assets/img/concurrent-objects/RedReleases.png" alt="" width="100%"></p></section><section id="blue-acquires-lock"><h2>Blue Acquires Lock</h2>
<p><img src="/assets/img/concurrent-objects/BlueLocks.png" alt="" width="100%"></p></section><section id="blue-inserts-element"><h2>Blue Inserts Element</h2>
<p><img src="/assets/img/concurrent-objects/BlueInserts.png" alt="" width="100%"></p></section><section id="blue-releases-lock"><h2>Blue Releases Lock</h2>
<p><img src="/assets/img/concurrent-objects/BlueReleases.png" alt="" width="100%"></p></section><section id="nice"><h1>Nice…</h1></section><section id="but"><h1>…but…</h1></section><section id="could-we-have-done-better"><h2>…Could we Have Done Better?</h2>
<p><img src="/assets/img/concurrent-objects/InsertBoth.png" alt="" width="100%"></p>
<p>How?</p>
<div style="margin-bottom: 12em"></div></section><section id="when-can-we-insert-concurrently"><h2>When Can We Insert Concurrently?</h2>
<div style="margin-bottom: 8em"></div></section><section id="what-should-we-lock"><h2>What Should we Lock?</h2>
<p>Not the whole list!</p>
<div style="margin-bottom: 12em"></div></section><section id="idea-locking-individual-nodes"><h2>Idea: Locking Individual Nodes</h2>
<p><img src="/assets/img/concurrent-objects/InsertBoth.png" alt="" width="100%"></p>
<p>Which nodes need to be locked?</p>
<div style="margin-bottom: 8em"></div></section><section id="locking-nodes-in-code"><h2>Locking Nodes in Code</h2>
<pre><code class="language-java">class Node {
    private Lock lock;
    public Node next;
    public Node prev;
    public int value;
	
    public void lock() { lock.lock(); }
    public void unlock() { lock.unlock(); }
}
</code></pre></section><section id="insertion-with-locked-nodes"><h2>Insertion with Locked Nodes</h2>
<pre><code class="language-java">    public void insert (Node nd, value) {
        Node cur = new Node(value);
		
        nd.lock();
        try {
            Node next = nd.getNext();
            if (next != null) next.lock();
            nd.next = cur;
            cur.prev = nd;
            cur.next = next;
            if (next != null) next.prev = cur;
        } finally {
            if (next != null) next.unlock();
            nd.unlock();
        }
    }
</code></pre></section><section id="concurrent-insertions"><h2>Concurrent Insertions</h2>
<p><img src="/assets/img/concurrent-objects/InsertBoth.png" alt="" width="100%"></p></section><section id="acquiring-locks"><h2>Acquiring Locks</h2>
<p><img src="/assets/img/concurrent-objects/BothBlock.png" alt="" width="100%"></p></section><section id="both-insert"><h2>Both Insert</h2>
<p><img src="/assets/img/concurrent-objects/BothInsert.png" alt="" width="100%"></p></section><section id="both-release"><h2>Both Release</h2>
<p><img src="/assets/img/concurrent-objects/BothRelease.png" alt="" width="100%"></p></section><section id="what-happens-with-contention"><h2>What Happens with Contention?</h2>
<p><img src="/assets/img/concurrent-objects/Contention.png" alt="" width="100%"></p></section><section id="red-acquires-locks-blue-waits"><h2>Red Acquires Locks (Blue Waits)</h2>
<p><img src="/assets/img/concurrent-objects/ContentionRedLock.png" alt="" width="100%"></p></section><section id="red-inserts--releases-locks"><h2>Red Inserts &amp; Releases Locks</h2>
<p><img src="/assets/img/concurrent-objects/ContentionRedInsert.png" alt="" width="100%"></p></section><section id="blue-finally-acquires-locks"><h2>Blue Finally Acquires Locks</h2>
<p><img src="/assets/img/concurrent-objects/ContentionBlueLock.png" alt="" width="100%"></p></section><section id="blue-inserts--releases-locks"><h2>Blue Inserts &amp; Releases Locks</h2>
<p><img src="/assets/img/concurrent-objects/ContentionBlueInsert.png" alt="" width="100%"></p></section><section id="this-seems-pretty-good"><h2>This Seems Pretty Good!</h2></section>
</div></div>


	  <script src="/assets/reveal.js-master/dist/reveal.js"></script>
	  <script src="/assets/reveal.js-master/plugin/math/math.js"></script>
	  <script src="/assets/reveal.js-master/plugin/zoom/zoom.js"></script>
	  <script src="/assets/reveal.js-master/plugin/notes/notes.js"></script>
	  <script src="/assets/reveal.js-master/plugin/search/search.js"></script>
	  <script src="/assets/reveal.js-master/plugin/markdown/markdown.js"></script>
	  <script src="/assets/reveal.js-master/plugin/highlight/highlight.js"></script>
	  <script>
	    

	    // Also available as an ES module, see:
	    // https://revealjs.com/initialization/
	    Reveal.initialize({
		controls: false,
		progress: true,
		center: true,
		hash: true,
		transition: 'none',
		math: {
		    config: 'TeX-AMS_HTML-full',
		    TeX: {
			Macros: {
			    R: '\\mathbb{R}',
			    set: [ '\\left\\{#1 \\; ; \\; #2\\right\\}', 2 ]
			}
		    }
		},


		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight, RevealMath ]
	    });

	  </script>

	</body>
</html>
	  

<!-- <\!-- load the reveal.js css & js (assuming you've put it in assets/)-\-> -->
<!-- <link -->
<!--   rel="stylesheet" -->
<!--   href="/assets/reveal.js-master/css/reveal.scss" -->
<!-- /> -->
<!-- <link -->
<!--   rel="stylesheet" -->
<!--   href="/assets/reveal.js-master/css/theme/source/white.scss" -->
<!-- /> -->
<!-- <script -->
<!--   src="/assets/reveal.js-master/js/reveal.js" -->
<!--   type="text/javascript" -->
<!-- ></script> -->

<!-- <\!-- configure the presentation, (you can tweak options to suit) -\-> -->
<!-- <script> -->
<!--   Reveal.initialize({ -->
<!--     // Display presentation control arrows -->
<!--     controls: false, -->

<!--     // Help the user learn the controls by providing hints, for example by -->
<!--     // bouncing the down arrow when they first encounter a vertical slide -->
<!--     controlsTutorial: false, -->

<!--     // Determines where controls appear, "edges" or "bottom-right" -->
<!--     controlsLayout: "bottom-right", -->

<!--     // Visibility rule for backwards navigation arrows; "faded", "hidden" -->
<!--     // or "visible" -->
<!--     controlsBackArrows: "faded", -->

<!--     // Display a presentation progress bar -->
<!--     progress: true, -->

<!--     // Display the page number of the current slide -->
<!--     slideNumber: false, -->

<!--     // Push each slide change to the browser history -->
<!--     history: false, -->

<!--     // Enable keyboard shortcuts for navigation -->
<!--     keyboard: true, -->

<!--     // Enable the slide overview mode -->
<!--     overview: true -->
<!--   }); -->
<!-- </script> -->
