<!doctype html>
<html lang="en">
	<head>

	  <meta name="viewport" content="width=device-width, initial-scale=1.0">
	  <meta charset="utf-8">

		<link rel="stylesheet" href="/assets/reveal.js-master/dist/reset.css">
		<link rel="stylesheet" href="/assets/reveal.js-master/dist/reveal.css">
		<link rel="stylesheet" href="/assets/css/condensation.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="/assets/reveal.js-master/plugin/highlight/monokai.css" id="highlight-theme">
		<link href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700" rel="stylesheet">

	</head>

	<body>


	  <!-- this is where the reveailfy filter gets applied -->
	  <div class="reveal"><div class="slides">






























































































































































































































































































<section id="lecture-22-concurrent-stacks"><h1>Lecture 22: Concurrent Stacks</h1></section><section id="overview"><h2>Overview</h2>
<ol>
  <li>Concurrent Stacks</li>
  <li>Elimination</li>
  <li>Consensus</li>
</ol></section><section id="last-time"><h2>Last Time</h2>
<p>Concurrent Queues:</p>
<ol>
  <li>Unbounded with locks</li>
  <li>Unbounded lock-free</li>
  <li>Bounded with locks</li>
</ol>
<p>Download and test the code yourself:</p>
<ul>
  <li><a href="/assets/java/2021s-cosc-273/ConcurrentQueues.zip"><code>ConcurrentQueues.zip</code></a></li>
</ul></section><section id="today-the-stack"><h2>Today: The Stack</h2>
<p>Basic operations</p>
<ul>
  <li>
<code>void push(T item)</code> add a new item to the top of the stack</li>
  <li>
<code>T pop()</code> remove top item from the stack and return it
    <ul>
      <li>throw <code>EmptyException</code> if stack was empty</li>
    </ul>
  </li>
</ul></section><section id="linked-list-implementation"><h2>Linked List Implementation</h2>
<p><img src="/assets/img/stacks/list-stack.png" alt="" width="100%"></p></section><section id="push-step-1-create-node"><h2>
<code>push()</code> Step 1: Create Node</h2>
<p><img src="/assets/img/stacks/list-stack-push-1.png" alt="" width="100%"></p></section><section id="push-step-2-set-next"><h2>
<code>push()</code> Step 2: Set <code>next</code>
</h2>
<p><img src="/assets/img/stacks/list-stack-push-2.png" alt="" width="100%"></p></section><section id="push-step-3-set-head"><h2>
<code>push()</code> Step 3: Set <code>head</code>
</h2>
<p><img src="/assets/img/stacks/list-stack-push-3.png" alt="" width="100%"></p></section><section id="push-complete"><h2>
<code>push()</code> Complete</h2>
<p><img src="/assets/img/stacks/list-stack-push-4.png" alt="" width="100%"></p></section><section id="pop"><h2>
<code>pop()</code>?</h2>
<p><img src="/assets/img/stacks/list-stack-push-4.png" alt="" width="100%"></p></section><section id="pop-step-1-store-value"><h2>
<code>pop()</code> Step 1: Store <code>value</code>
</h2>
<p><img src="/assets/img/stacks/list-stack-pop-1.png" alt="" width="100%"></p></section><section id="pop-step-2-update-head"><h2>
<code>pop()</code> Step 2: Update <code>head</code>
</h2>
<p><img src="/assets/img/stacks/list-stack-pop-2.png" alt="" width="100%"></p></section><section id="pop-step-3-return-value"><h2>
<code>pop()</code> Step 3: Return <code>value</code>
</h2>
<p><img src="/assets/img/stacks/list-stack-pop-3.png" alt="" width="100%"></p></section><section id="concurrent-stack"><h2>Concurrent Stack</h2>
<p>With locks:</p>
<ul>
  <li>Since all operations modify <code>head</code>, coarse locking is natural choice</li>
</ul>
<p>Without locks?</p>
<div style="margin-bottom: 12em"></div></section><section id="a-lock-free-stack"><h2>A Lock-free Stack</h2>
<p>Use linked-list implementation</p>
<ul>
  <li>Logic is simpler than queues’ because all operations affect same node</li>
  <li>Idea:
    <ul>
      <li>store <code>top</code> as an <code>AtomicReference&lt;Node&gt;</code>
</li>
      <li>use <code>compareAndSet</code> to modify <code>top</code>
        <ul>
          <li>success, or retry</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Unlike queue:
    <ul>
      <li>item on top of stack precisely when <code>top</code> points to item’s <code>Node</code>
</li>
    </ul>
  </li>
</ul></section><section id="implementing-the-lock-free-stack"><h2>Implementing the Lock-Free Stack</h2>
<pre><code class="language-java">public class LockFreeStack&lt;T&gt; implements SimpleStack&lt;T&gt; {
    AtomicReference&lt;Node&gt; top = new AtomicReference&lt;Node&gt;(null);

    public void push(T item) {...}

    public T pop() throws EmptyException {...}
    
    class Node {
	public T value;
	public AtomicReference&lt;Node&gt; next;
    
	public Node(T value) {
	    this.value = value;
	    this.next  = new AtomicReference&lt;Node&gt;(null);
	}
    }    

}
</code></pre></section><section id="implementing-push"><h2>Implementing <code>push</code>
</h2>
<pre><code class="language-java">    public void push(T item) {
	
	Node nd = new Node(item);
	Node oldTop = top.get();
	nd.next.set(oldTop);
	
	while (!top.compareAndSet(oldTop, nd)) {
	    oldTop = top.get();
	    nd.next.set(oldTop);	    
	}
    }
</code></pre></section><section id="implementing-pop"><h2>Implementing <code>pop</code>
</h2>
<pre><code class="language-java">    public T pop() throws EmptyException {
	while (true) {
	    Node oldTop = top.get();
	    
	    if (oldTop == null) {
		throw new EmptyException();
	    }

	    Node newTop = oldTop.next.get();

	    if (top.compareAndSet(oldTop, newTop)) {
		return oldTop.value;
	    }
	}
    }
</code></pre></section><section id="sequential-bottleneck"><h2>Sequential Bottleneck</h2>
<p>Modifying <code>top</code></p>
<ul>
  <li>No matter how many threads, <code>push</code>/<code>pop</code> rate limited by <code>top.compareAndSet(...)</code>
</li>
  <li>This seems inherent to any stack…</li>
</ul>
<div style="margin-bottom: 8em"></div>
<p>… or is it?</p></section><section id="elimination"><h2>Elimination</h2>
<p>Consider several concurrent accesses to a stack:</p>
<ul>
  <li>T1 calls <code>stk.push(item1)</code>
</li>
  <li>T2 calls <code>stk.push(item2)</code>
</li>
  <li>T3 calls <code>stk.pop()</code>
</li>
  <li>T4 calls <code>stk.push(item4)</code>
</li>
  <li>T5 calls <code>stk.pop()</code>
</li>
  <li>T6 calls <code>stk.pop()</code>
</li>
</ul>
<p><strong>Trick Question.</strong> What is the state of <code>stk</code> after these calls? What do <code>pop</code> calls return?</p>
<div style="margin-bottom: 8em"></div></section><section id="concurrent-calls"><h2>Concurrent Calls</h2>
<p><img src="/assets/img/concurrent-stack/concurrent-stack.png" alt="" width="100%"></p></section><section id="contention"><h2>Contention!</h2>
<p><img src="/assets/img/concurrent-stack/contention-1.png" alt="" width="100%"></p></section><section id="thead-4-wins"><h2>Thead 4 Wins</h2>
<p><img src="/assets/img/concurrent-stack/contention-2.png" alt="" width="100%"></p></section><section id="contention-1"><h2>Contention!</h2>
<p><img src="/assets/img/concurrent-stack/contention-3.png" alt="" width="100%"></p></section><section id="thead-3-wins"><h2>Thead 3 Wins</h2>
<p><img src="/assets/img/concurrent-stack/contention-4.png" alt="" width="100%"></p></section><section id="contention-2"><h2>Contention!</h2>
<p><img src="/assets/img/concurrent-stack/contention-5.png" alt="" width="100%"></p></section><section id="thead-6-wins"><h2>Thead 6 Wins</h2>
<p><img src="/assets/img/concurrent-stack/contention-6.png" alt="" width="100%"></p></section><section id="contention-3"><h2>Contention!</h2>
<p><img src="/assets/img/concurrent-stack/contention-7.png" alt="" width="100%"></p></section><section id="thead-2-wins"><h2>Thead 2 Wins</h2>
<p><img src="/assets/img/concurrent-stack/contention-8.png" alt="" width="100%"></p></section><section id="contention-4"><h2>Contention!</h2>
<p><img src="/assets/img/concurrent-stack/contention-9.png" alt="" width="100%"></p></section><section id="thead-1-wins"><h2>Thead 1 Wins</h2>
<p><img src="/assets/img/concurrent-stack/contention-10.png" alt="" width="100%"></p></section><section id="no-contention-thread-5-succeeds"><h2>No Contention; Thread 5 Succeeds</h2>
<p><img src="/assets/img/concurrent-stack/contention-11.png" alt="" width="100%"></p></section><section id="what-do-we-need-the-stack-for"><h2>What do we need the stack for?</h2></section><section id="equivalent-execution"><h2>Equivalent Execution:</h2>
<ol>
  <li>Thread 6 <code>pop</code>s</li>
  <li>Thread 1 sends <code>1</code> to Thread 5</li>
  <li>Thread 4 sends <code>4</code> to Thread 3</li>
  <li>Thread 2 <code>push</code>es <code>2</code>
</li>
</ol>
<p>Note: Steps 1, 2, and 3 can be performed in parallel!</p></section><section id="exchanges"><h2>Exchanges</h2>
<p><img src="/assets/img/concurrent-stack/exchanges-1.png" alt="" width="100%"></p></section><section id="exchanges-1"><h2>Exchanges</h2>
<p><img src="/assets/img/concurrent-stack/exchanges-2.png" alt="" width="100%"></p></section><section id="observation"><h2>Observation</h2>
<ul>
  <li>Stack operations cannot be parallelized</li>
  <li>Exchanges between threads can be!</li>
</ul>
<p>The stack was just slowing us down</p></section><section id="a-different-strategy"><h2>A Different Strategy</h2>
<ol>
  <li>Attempt to <code>push</code>/<code>pop</code> to stack
    <ul>
      <li>if success, good job</li>
    </ul>
  </li>
  <li>If attempt fails there was contention; try to find a partner
    <ul>
      <li>if <code>push</code>, try to find a <code>pop</code> and give them your value</li>
      <li>if <code>pop</code>, try to find a <code>push</code> and take their value</li>
    </ul>
  </li>
</ol>
<p>This strategy is called <strong>elimination</strong></p>
<ul>
  <li>eliminate unnecessary calls to <code>push</code>/<code>pop</code>
</li>
</ul></section><section id="need-another-object"><h2>Need Another Object</h2>
<p>The <code>Exchanger</code> object:</p>
<ul>
  <li>Stores reference to item to be exchanged</li>
  <li>Has method <code>exchange(T item,...)</code>
    <ul>
      <li>
<code>...</code> parameters for timeout</li>
    </ul>
  </li>
</ul>
<p>Specification of <code>Exchanger&lt;T&gt; ex</code>:</p>
<ul>
  <li>
<code>ThreadA</code> calls <code>ex.exchange(itemA,...)</code>
</li>
  <li>
<code>ThreadB</code> calls <code>ex.exchange(itemB,...)</code>
</li>
  <li>
<code>ThreadA</code> receives <code>itemB</code>
</li>
  <li>
<code>ThreadB</code> receives <code>itemA</code>
</li>
</ul></section><section id="exchange-semantics"><h2>Exchange Semantics</h2>
<ul>
  <li>Use <code>ex.exchange(null,...)</code> to indicate <code>pop</code>
</li>
  <li>Use <code>ex.exchange(item,...)</code> to indicate <code>push(item)</code>
</li>
</ul>
<p>Exchange a success if:</p>
<ul>
  <li>
<code>ThreadA</code> calls <code>ex.exchange(item)</code>
    <ul>
      <li>call returns <code>null</code> (i.e., other call was a <code>pop</code>)</li>
    </ul>
  </li>
  <li>
<code>ThreadB</code> calls <code>ex.exchange()</code>
    <ul>
      <li>call returns <code>item != null</code> (i.e. other call was <code>push(item)</code>)</li>
    </ul>
  </li>
</ul></section><section id="finding-a-partner"><h2>Finding a Partner</h2>
<p>Store an array of several <code>Exchanger</code> instances</p>
<ol>
  <li>Attempt to <code>push</code>/<code>pop</code> to stack
    <ul>
      <li>if success, good job</li>
    </ul>
  </li>
  <li>If attempt fails there was contention; try to find a partner
    <ul>
      <li>pick random <code>Exchanger ex</code> in array</li>
      <li>call
        <ul>
          <li>
<code>ex.exchange(null)</code> for <code>pop()</code>
</li>
          <li>
<code>ex.exchange(item)</code> for <code>push()</code>
</li>
        </ul>
      </li>
      <li>wait until success, or timeout
        <ul>
          <li>timeout $\implies$ back to step 1</li>
        </ul>
      </li>
    </ul>
  </li>
</ol></section><section id="elimination-stack"><h2>Elimination Stack</h2>
<p><img src="/assets/img/concurrent-stack/exchange-obj-1.png" alt="" width="100%"></p></section><section id="witness-contention"><h2>Witness Contention</h2>
<p><img src="/assets/img/concurrent-stack/exchange-obj-2.png" alt="" width="100%"></p></section><section id="attempt-to-exchange"><h2>Attempt to Exchange</h2>
<p><img src="/assets/img/concurrent-stack/exchange-obj-3.png" alt="" width="100%"></p></section><section id="some-exchanges-successful"><h2>Some Exchanges Successful!</h2>
<p><img src="/assets/img/concurrent-stack/exchange-obj-4.png" alt="" width="100%"></p></section><section id="unsuccessful-exchanges-try-again"><h2>Unsuccessful Exchanges Try Again</h2>
<p><img src="/assets/img/concurrent-stack/exchange-obj-5.png" alt="" width="100%"></p></section><section id="challenges"><h2>Challenges</h2>
<ol>
  <li>Implementation (see <em>AoMP</em> Section 11.4)
    <ul>
      <li>natural idea</li>
      <li>technically challenging</li>
    </ul>
  </li>
  <li>Parameter tuning
    <ul>
      <li>how large should <code>Exchanger</code> array be?</li>
      <li>dynamic tuning?
        <ul>
          <li>detect contention for exchangers, and use more?</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>
<p><strong>Question.</strong> When might this approach be practical?</p>
<div style="margin-bottom: 6em"></div></section><section id="consensus"><h1>Consensus</h1></section><section id="mission-critical-components"><h2>Mission Critical Components</h2>
<p>Suppose you’re designing an airplane</p>
<ol>
  <li>Need computers to control <em>everything</em>
    <ul>
      <li>sensors for speed, thrust, flap positions, pitch, roll, yaw</li>
      <li>must adjust constantly to fly</li>
    </ul>
  </li>
  <li>But computers occassionally (regularly) crash/need restart</li>
</ol>
<p>How to design around this issue?</p>
<div style="margin-bottom: 8em"></div></section><section id="fault-tolerance-through-duplication"><h2>Fault-Tolerance through Duplication?</h2>
<p>Have multiple duplicate, independent systems</p>
<ul>
  <li>systems run in parallel</li>
  <li>highly unlikely both crash simultaneously
    <ul>
      <li>restarts are infrequent</li>
      <li>restarting one system won’t affect other system</li>
    </ul>
  </li>
</ul>
<p>The end of our worries?</p>
<div style="margin-bottom: 8em"></div></section><section id="trouble-ahead"><h2>Trouble Ahead</h2>
<p>Suppose all systems working normally, but</p>
<ul>
  <li>system 1 says increase thrust</li>
  <li>system 2 says decrease thrust</li>
  <li>system 3 not responding (restart?)</li>
</ul>
<p>What do we do?</p>
<div style="margin-bottom: 8em"></div></section><section id="the-problem-of-consensus"><h2>The Problem of Consensus</h2>
<p>Have multiple systems with different inputs</p>
<ul>
  <li>For us, binary inputs
    <ul>
      <li>
<code>0</code> = decrease thrust</li>
      <li>
<code>1</code> = increase thrust</li>
    </ul>
  </li>
</ul>
<p>Goal:</p>
<ul>
  <li>agree on same output</li>
</ul></section><section id="requirements"><h2>Requirements</h2>
<p>Consensus Problem:</p>
<ul>
  <li>
<strong>Agreement</strong>: all systems output the same value</li>
  <li>
<strong>Validity</strong>: if all systems have the same intput, they all output that value</li>
  <li>
<strong>Termination</strong>: all (non-faulty) processes decide on an output and terminate after a finite number of steps</li>
</ul>
<p><strong>Coming up</strong>: How can we achieve consensus if some processes might fail?</p></section>
</div></div>


	  <script src="/assets/reveal.js-master/dist/reveal.js"></script>
	  <script src="/assets/reveal.js-master/plugin/math/math.js"></script>
	  <script src="/assets/reveal.js-master/plugin/zoom/zoom.js"></script>
	  <script src="/assets/reveal.js-master/plugin/notes/notes.js"></script>
	  <script src="/assets/reveal.js-master/plugin/search/search.js"></script>
	  <script src="/assets/reveal.js-master/plugin/markdown/markdown.js"></script>
	  <script src="/assets/reveal.js-master/plugin/highlight/highlight.js"></script>
	  <script>
	    

	    // Also available as an ES module, see:
	    // https://revealjs.com/initialization/
	    Reveal.initialize({
		controls: false,
		progress: true,
		center: true,
		hash: true,
		transition: 'none',
		math: {
		    config: 'TeX-AMS_HTML-full',
		    TeX: {
			Macros: {
			    R: '\\mathbb{R}',
			    set: [ '\\left\\{#1 \\; ; \\; #2\\right\\}', 2 ]
			}
		    }
		},


		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight, RevealMath ]
	    });

	  </script>

	</body>
</html>
	  

<!-- <\!-- load the reveal.js css & js (assuming you've put it in assets/)-\-> -->
<!-- <link -->
<!--   rel="stylesheet" -->
<!--   href="/assets/reveal.js-master/css/reveal.scss" -->
<!-- /> -->
<!-- <link -->
<!--   rel="stylesheet" -->
<!--   href="/assets/reveal.js-master/css/theme/source/white.scss" -->
<!-- /> -->
<!-- <script -->
<!--   src="/assets/reveal.js-master/js/reveal.js" -->
<!--   type="text/javascript" -->
<!-- ></script> -->

<!-- <\!-- configure the presentation, (you can tweak options to suit) -\-> -->
<!-- <script> -->
<!--   Reveal.initialize({ -->
<!--     // Display presentation control arrows -->
<!--     controls: false, -->

<!--     // Help the user learn the controls by providing hints, for example by -->
<!--     // bouncing the down arrow when they first encounter a vertical slide -->
<!--     controlsTutorial: false, -->

<!--     // Determines where controls appear, "edges" or "bottom-right" -->
<!--     controlsLayout: "bottom-right", -->

<!--     // Visibility rule for backwards navigation arrows; "faded", "hidden" -->
<!--     // or "visible" -->
<!--     controlsBackArrows: "faded", -->

<!--     // Display a presentation progress bar -->
<!--     progress: true, -->

<!--     // Display the page number of the current slide -->
<!--     slideNumber: false, -->

<!--     // Push each slide change to the browser history -->
<!--     history: false, -->

<!--     // Enable keyboard shortcuts for navigation -->
<!--     keyboard: true, -->

<!--     // Enable the slide overview mode -->
<!--     overview: true -->
<!--   }); -->
<!-- </script> -->
