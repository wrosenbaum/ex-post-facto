<!doctype html>
<html lang="en">
	<head>

	  <meta name="viewport" content="width=device-width, initial-scale=1.0">
	  <meta charset="utf-8">

		<link rel="stylesheet" href="/assets/reveal.js-master/dist/reset.css">
		<link rel="stylesheet" href="/assets/reveal.js-master/dist/reveal.css">
		<link rel="stylesheet" href="/assets/css/condensation.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="/assets/reveal.js-master/plugin/highlight/monokai.css" id="highlight-theme">
		<link href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700" rel="stylesheet">

	</head>

	<body>


	  <!-- this is where the reveailfy filter gets applied -->
	  <div class="reveal"><div class="slides">










































































































































































































































<section id="lab-week-11-sorting"><h1>Lab Week 11: Sorting</h1></section><section id="overview"><h2>Overview</h2>
<ol>
  <li>Sorting</li>
  <li>Divide &amp; Conquer Strategies</li>
  <li>Parallel Sorting</li>
  <li>Lab 05: Sorting</li>
  <li>Sorting Networks</li>
</ol></section><section id="sorting"><h2>Sorting</h2>
<p>Sorting is a fundamental operation in computer science</p>
<p><img src="/assets/img/knuth/sorting-and-searching.jpeg" alt="" width="25%"></p></section><section id="goal"><h2>Goal</h2>
<p>Start with an unordered array</p>
<pre><code class="language-text">[5, 7, 2, 3, 5, 2, 8, 1, 1, 5]
</code></pre>
<p>and transform it into a sorted array</p>
<pre><code>[1, 1, 2, 2, 3, 5, 5, 5, 7, 8]
</code></pre>
<p>Same elements in increasing order.</p></section><section id="simplistic-sorting-strategies"><h1>Simplistic Sorting Strategies</h1></section><section id="selection-sort"><h2>Selection Sort</h2>
<ol>
  <li>Find smallest element; put at index 1</li>
  <li>Find next smallest; put at index 2</li>
  <li>…</li>
</ol>
<pre><code class="language-text">5                        7                        2                        3
</code></pre>
<div style="margin-bottom: 12em"></div></section><section id="insertion-sort"><h2>Insertion sort</h2>
<ol>
  <li>Iterate <code>j = 1, 2, ...</code>
</li>
  <li>Insert <code>j</code>th element in sorted order by pairwise swaps</li>
</ol>
<pre><code class="language-text">5                        7                        2                        3
</code></pre>
<div style="margin-bottom: 12em"></div></section><section id="bubble-sort"><h2>Bubble sort</h2>
<ul>
  <li>Repeat until sorted:
    <ol>
      <li>Iterate over array:</li>
      <li>Swap adjacent pairs if out of order</li>
    </ol>
  </li>
</ul>
<pre><code class="language-text">5                        7                        2                        3
</code></pre>
<div style="margin-bottom: 12em"></div></section><section id="questions"><h2>Questions</h2>
<ul>
  <li>Are any of these strategies efficient?</li>
</ul>
<div style="margin-bottom: 4em"></div>
<ul>
  <li>Can they be parallelized easily?</li>
</ul>
<div style="margin-bottom: 4em"></div>
<ul>
  <li>Are these algorithms practical?</li>
</ul>
<div style="margin-bottom: 4em"></div></section><section id="faster-sequential-algorithms-divide-and-conquer"><h1>Faster Sequential Algorithms: Divide and Conquer</h1></section><section id="merge-sort"><h2>Merge Sort</h2>
<ol>
  <li>Divide array in half</li>
  <li>Sort left half (recursively)</li>
  <li>Sort right half (recursively)</li>
  <li>Merge sorted halves</li>
</ol>
<pre><code class="language-text">7                        5                        3                        2
</code></pre>
<div style="margin-bottom: 12em"></div></section><section id="randomized-quick-sort"><h2>Randomized Quick Sort</h2>
<ol>
  <li>Pick random “pivot” element</li>
  <li>Put all smaller elements on left</li>
  <li>Put all larger elements on right</li>
  <li>Recursively sort left/right sides</li>
</ol>
<pre><code class="language-text">5           4            7            9            2            8           3
</code></pre>
<div style="margin-bottom: 12em"></div></section><section id="questions-1"><h2>Questions</h2>
<ul>
  <li>Are any of these strategies efficient?</li>
</ul>
<div style="margin-bottom: 4em"></div>
<ul>
  <li>Can they be parallelized easily?</li>
</ul>
<div style="margin-bottom: 4em"></div>
<ul>
  <li>Are these algorithms practical?</li>
</ul>
<div style="margin-bottom: 4em"></div></section><section id="quicksort-in-more-depth"><h2>Quicksort in More Depth</h2>
<ol>
  <li>If we’re unlucky, it can be slow
    <ul>
      <li>e.g., always pick smallest/largest element as pivot</li>
    </ul>
  </li>
  <li>In practice it tends to be fast
    <ul>
      <li>it is extremely unlikely that we are often unlucky</li>
    </ul>
  </li>
  <li>Many built-in sorting procedures are variants of quicksort</li>
</ol></section><section id="parallelizing-quicksort"><h2>Parallelizing Quicksort</h2>
<p>Sequential:</p>
<ul>
  <li>Select pivot</li>
  <li>Divide array
    <ul>
      <li>left half smaller than pivot</li>
      <li>right half larger than pivot</li>
    </ul>
  </li>
</ul>
<p>Parallel:</p>
<ul>
  <li>Sort left half</li>
  <li>Sort right half</li>
</ul></section><section id="question"><h2>Question</h2>
<p>Why is parallelization potentially problematic?</p>
<div style="margin-bottom: 18em"></div></section><section id="overcoming-imbalance"><h2>Overcoming Imbalance</h2>
<p>Creating more tasks is helpful?</p>
<ul>
  <li>Smaller tasks completed faster</li>
  <li>Larger tasks broken down</li>
</ul>
<p>Efficient, as long as no idle processes</p>
<ul>
  <li>Thread pools are good for this!</li>
  <li>Need to ensure tasks performed in correct order</li>
</ul></section><section id="implementation"><h2>Implementation</h2>
<p>Recall Fork-Join pools:</p>
<ul>
  <li>thread pool with efficient support for <em>forking</em>:
    <ul>
      <li>divide a task into two or more sub-tasks</li>
      <li>complete sub-tasks</li>
      <li>combine solutions (if necessary)</li>
    </ul>
  </li>
  <li>tasks themselves spawn new sub-tasks</li>
</ul>
<p>Creating FJ pool:</p>
<pre><code class="language-java">import java.util.concurrent.ForkJoinPool;
...
ForkJoinPool pool = new ForkJoinPool(POOL_SIZE);
...
pool.invoke(new SomeTask(...));
</code></pre></section><section id="recursive-actions"><h2>Recursive Actions</h2>
<p>Tasks for fork-join pools (without return values)</p>
<ul>
  <li>Extend <code>RecursiveAction</code>
</li>
  <li>Override <code>compute()</code> method</li>
</ul>
<pre><code class="language-java">class MyTask extends RecursiveAction {
	...
    @Override
    protected void compute () {
	
        //... compute stuff ...//
		
        MyTask sub1 = new MyTask(...)   // create a sub-task
        sub1.fork();                    // start subtask
		
        MyTask sub2 = new MyTask(...)   // create another sub-task
        sub2.fork();                    // start other subtask
		
        sub1.join();                    // wait for sub1 to complete
        sub2.join();                    // wait for sub2 to complete
		
        //... compute more stuff stuff ...//
    }	
}
</code></pre></section><section id="parallel-implementation-of-quicksort"><h2>Parallel Implementation of Quicksort</h2>
<p>Basic task: Sort array between index <code>i</code> and <code>j</code></p></section><section id="lab-05-sorting-optional"><h2>Lab 05: Sorting (Optional)</h2>
<p>Your task:</p>
<ul>
  <li>Write a method that sorts a large array of <code>double</code>s as quickly as possible
    <ul>
      <li>large = &gt; 1 million elements</li>
    </ul>
  </li>
  <li>Should be faster than <code>Arrays.sort()</code>
</li>
</ul></section><section id="lab-05-demo"><h2>Lab 05 Demo</h2></section><section id="suggestions"><h2>Suggestions</h2>
<ul>
  <li>Quicksort is a good starting point</li>
  <li>Use <code>ForkJoinPool</code>
</li>
  <li>Use a reasonably large base case
    <ul>
      <li>
<code>Arrays.sort()</code> as a sub-routine</li>
      <li>it is quite fast for smaller arrays!</li>
    </ul>
  </li>
  <li>Be careful about memory access pattern
    <ul>
      <li>cache performance is crucial for large arrays</li>
    </ul>
  </li>
</ul></section><section id="sorting-networks"><h1>Sorting Networks</h1></section><section id="insertion-sort-revisited"><h2>Insertion Sort, Revisited</h2>
<pre><code class="language-java">for (int i = 1; i &lt; data.length; ++i) {
    for (int j = i; j &gt; 0; --j) {
        if (data[j-1] &gt; data[j]) {
            swap(data, j-1, j)		
        }
    }
}
</code></pre>
<div style="margin-bottom: 12em"></div></section><section id="comparators-visualizing-swaps"><h2>Comparators: Visualizing Swaps</h2>
<pre><code class="language-java">        if (data[i] &gt; data[j]) {
            swap(data, i, j)
        }

</code></pre>
<div style="margin-bottom: 12em"></div></section><section id="insertion-sort-visualized"><h2>Insertion Sort, Visualized</h2>
<pre><code class="language-java">for (int i = 1; i &lt; data.length; ++i) {
    for (int j = i; j &gt; 0; --j) {
        if (data[j-1] &gt; data[j]) {
            swap(data, j-1, j)		
        }
    }
}
</code></pre>
<div style="margin-bottom: 16em"></div></section><section id="which-operations-can-be-parallelized"><h2>Which Operations can be Parallelized?</h2>
<div style="margin-bottom: 18em"></div></section><section id="sorting-in-parallel"><h2>Sorting In Parallel</h2>
<div style="margin-bottom: 18em"></div></section><section id="how-fast-is-it"><h2>How Fast is it?</h2>
<div style="margin-bottom: 18em"></div></section><section id="measuring-speed"><h2>Measuring Speed</h2>
<p><em>depth</em> = max # of comparators on any path from input to output</p>
<div style="margin-bottom: 16em"></div></section><section id="bubble-sort-revisited"><h2>Bubble Sort, Revisited</h2>
<pre><code class="language-java">for (int m = data.length - 1; m &gt; 0; --m) {
    for (int i = 0; i &lt; m; ++i) {
        if (data[i] &gt; data[i+1]) {
            swap(data, i, i+1)		
        }
    }
}
</code></pre>
<div style="margin-bottom: 16em"></div></section><section id="which-operations-can-be-parallelized-1"><h2>Which Operations can be Parallelized?</h2>
<div style="margin-bottom: 18em"></div></section><section id="parallelized-version"><h2>Parallelized Version</h2>
<div style="margin-bottom: 18em"></div></section><section id="does-it-look-familiar"><h2>Does it Look Familiar?</h2>
<div style="margin-bottom: 18em"></div></section><section id="huh"><h2>Huh</h2>
<ul>
  <li>Insertion sort and bubble sort perform precisely same operations
    <ul>
      <li>only differ in the order in which comparisons are made</li>
    </ul>
  </li>
  <li>
    <p>When fuly parallelized, both are same sorting network</p>
  </li>
  <li>Parallel versions are reasonably efficient
    <ul>
      <li>depth $\approx 2 n$</li>
    </ul>
  </li>
</ul></section><section id="optimal-sorting-network-n--4"><h2>Optimal Sorting Network, $n = 4$</h2>
<div style="margin-bottom: 18em"></div></section><section id="current-state"><h2>Current State</h2>
<p>What is known:</p>
<ul>
  <li>Optimal depth sorting networks for $n \leq 17$</li>
</ul>
<p>What is not known:</p>
<ul>
  <li>Optimal depth sorting networks for $n \geq 18$</li>
</ul></section>
</div></div>


	  <script src="/assets/reveal.js-master/dist/reveal.js"></script>
	  <script src="/assets/reveal.js-master/plugin/math/math.js"></script>
	  <script src="/assets/reveal.js-master/plugin/zoom/zoom.js"></script>
	  <script src="/assets/reveal.js-master/plugin/notes/notes.js"></script>
	  <script src="/assets/reveal.js-master/plugin/search/search.js"></script>
	  <script src="/assets/reveal.js-master/plugin/markdown/markdown.js"></script>
	  <script src="/assets/reveal.js-master/plugin/highlight/highlight.js"></script>
	  <script>
	    

	    // Also available as an ES module, see:
	    // https://revealjs.com/initialization/
	    Reveal.initialize({
		controls: false,
		progress: true,
		center: true,
		hash: true,
		transition: 'none',
		math: {
		    config: 'TeX-AMS_HTML-full',
		    TeX: {
			Macros: {
			    R: '\\mathbb{R}',
			    set: [ '\\left\\{#1 \\; ; \\; #2\\right\\}', 2 ]
			}
		    }
		},


		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight, RevealMath ]
	    });

	  </script>

	</body>
</html>
	  

<!-- <\!-- load the reveal.js css & js (assuming you've put it in assets/)-\-> -->
<!-- <link -->
<!--   rel="stylesheet" -->
<!--   href="/assets/reveal.js-master/css/reveal.scss" -->
<!-- /> -->
<!-- <link -->
<!--   rel="stylesheet" -->
<!--   href="/assets/reveal.js-master/css/theme/source/white.scss" -->
<!-- /> -->
<!-- <script -->
<!--   src="/assets/reveal.js-master/js/reveal.js" -->
<!--   type="text/javascript" -->
<!-- ></script> -->

<!-- <\!-- configure the presentation, (you can tweak options to suit) -\-> -->
<!-- <script> -->
<!--   Reveal.initialize({ -->
<!--     // Display presentation control arrows -->
<!--     controls: false, -->

<!--     // Help the user learn the controls by providing hints, for example by -->
<!--     // bouncing the down arrow when they first encounter a vertical slide -->
<!--     controlsTutorial: false, -->

<!--     // Determines where controls appear, "edges" or "bottom-right" -->
<!--     controlsLayout: "bottom-right", -->

<!--     // Visibility rule for backwards navigation arrows; "faded", "hidden" -->
<!--     // or "visible" -->
<!--     controlsBackArrows: "faded", -->

<!--     // Display a presentation progress bar -->
<!--     progress: true, -->

<!--     // Display the page number of the current slide -->
<!--     slideNumber: false, -->

<!--     // Push each slide change to the browser history -->
<!--     history: false, -->

<!--     // Enable keyboard shortcuts for navigation -->
<!--     keyboard: true, -->

<!--     // Enable the slide overview mode -->
<!--     overview: true -->
<!--   }); -->
<!-- </script> -->
