<!doctype html>
<html lang="en">
	<head>

	  <meta name="viewport" content="width=device-width, initial-scale=1.0">
	  <meta charset="utf-8">

		<link rel="stylesheet" href="/assets/reveal.js-master/dist/reset.css">
		<link rel="stylesheet" href="/assets/reveal.js-master/dist/reveal.css">
		<link rel="stylesheet" href="/assets/css/condensation.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="/assets/reveal.js-master/plugin/highlight/monokai.css" id="highlight-theme">
		<link href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700" rel="stylesheet">

	</head>

	<body>


	  <!-- this is where the reveailfy filter gets applied -->
	  <div class="reveal"><div class="slides">
































































































































































































































<section id="lecture-05-mutual-exclusion-3"><h1>Lecture 05: Mutual Exclusion 3</h1></section><section id="outline"><h2>Outline</h2>
<ol>
  <li>Peterson Lock Correctness</li>
  <li>Lamport’s Bakery Algorithm</li>
  <li>Memory Lower Bounds</li>
</ol></section><section id="last-time"><h2>Last Time</h2>
<p>Introduced the Peterson Lock:</p>
<pre><code class="language-java">class Peterson implements Lock {
    private boolean[] flag = new boolean[2];
	private int victim;
	
	public void lock () {
	   int i = ThreadID.get(); // get my ID, 0 or 1
	   int j = 1 - i;          // other thread's ID
	   
	   flag[i] = true;         // set my flag
	   victim = i;             // set myself to be victim
	   while (flag[j] &amp;&amp; victim == i) {
	       // wait
	   }
	}
	
	public void unlock () {
	    int i = ThreadID.get();
		flag[i] = false;
	}
}
</code></pre></section><section id="features"><h2>Features</h2>
<p>Claims:</p>
<ol>
  <li>
<code>Peterson</code> satisfies mutual exclusion</li>
  <li>
<code>Peterson</code> satisfies <em>starvation-freedom</em>
    <ul>
      <li>stronger than deadlock-freedom</li>
      <li>previous lock only achieved deadlock-freedom</li>
    </ul>
  </li>
</ol></section><section id="proof-of-mutual-exclusion-i"><h2>Proof of Mutual Exclusion I</h2>
<p>Suppose not…</p>
<ul>
  <li>\(A\) and \(B\) both in critical section (CS) at same time</li>
</ul></section><section id="proof-of-mutual-exclusion-ii"><h2>Proof of Mutual Exclusion II</h2>
<ul>
  <li>Actions of \(A\):
    <ul>
      <li>\((A.1)\) writes <code>flag[A] = true</code>
</li>
      <li>\((A.2)\) writes <code>victim = A</code>
</li>
      <li>\((A.3)\) reads <code>flag[B]</code>
</li>
      <li>\((A.4)\) reads <code>victim</code>
</li>
    </ul>
  </li>
  <li>Actions of \(B\):
    <ul>
      <li>\((B.1)\) writes <code>flag[B] = true</code>
</li>
      <li>\((B.2)\) writes <code>victim = B</code>
</li>
      <li>\((B.3)\) reads <code>flag[A]</code>
</li>
      <li>\((B.4)\) reads <code>victim</code>
</li>
    </ul>
  </li>
</ul></section><section id="proof-of-mutual-exclusion-iii"><h2>Proof of Mutual Exclusion III</h2>
<p>Suppose \((B.2) \to (A.2)\):</p>
<ul>
  <li>
    <p>i.e., \(A\) wrote to <code>victim</code> last</p>
  </li>
  <li>
    <p>if not, continue argument with roles of \(A\) and \(B\) reversed</p>
  </li>
</ul></section><section id="timelines"><h2>Timelines</h2>
<div style="margin-bottom: 18em"></div></section><section id="conclusion"><h2>Conclusion</h2>
<p>The Peterson lock satisfies mutual exclusion</p></section><section id="proof-of-starvation-freedom-i"><h2>Proof of Starvation-Freedom I</h2>
<p>Suppose not:</p>
<ul>
  <li>Some thread runs forever in <code>lock()</code> method</li>
  <li>Assume it is thread \(A\)</li>
</ul>
<pre><code class="language-java">	public void lock () {
	   int i = ThreadID.get(); // get my ID, 0 or 1
	   int j = 1 - i;          // other thread's ID
	   
	   flag[i] = true;         // set my flag
	   victim = i;             // set myself to be victim
	   while (flag[j] &amp;&amp; victim == i) {
	       // wait
	   }
	}
</code></pre>
<ul>
  <li>\(A\) is stuck in <code>while</code> loop</li>
</ul></section><section id="proof-of-starvation-freedom-ii"><h2>Proof of Starvation-Freedom II</h2>
<p>\(A\) stuck in:</p>
<pre><code class="language-java">	   while (flag[B] &amp;&amp; victim == A) {
	       // wait
	   }
</code></pre>
<ul>
  <li>If \(B\) leaves CS, \(B\) sets <code>flag[B] = false</code>
</li>
  <li>If \(B\) calls <code>lock()</code> again, sets <code>victim = B</code>
</li>
  <li>In in either case, \(A\) eventually breaks out of loop</li>
</ul>
<p>So</p>
<ul>
  <li>Must be that \(B\) also stuck in <code>lock()</code> call</li>
</ul></section><section id="proof-of-starvation-freedom-iii"><h2>Proof of Starvation-Freedom III</h2>
<ul>
  <li>Must be that \(B\) also stuck in <code>lock()</code> call</li>
  <li>But then:
    <ul>
      <li>
<code>flag[B] &amp;&amp; victim == A</code> is true (\(A\) in <code>while</code> loop)</li>
      <li>
<code>flag[A] &amp;&amp; victim == B</code> is true (\(B\) in <code>while</code> loop)</li>
    </ul>
  </li>
  <li>This is a contradiction!
    <ul>
      <li>
<code>victim</code> cannot be both <code>A</code> and <code>B</code>
</li>
    </ul>
  </li>
</ul></section><section id="conclusion-1"><h2>Conclusion</h2>
<ul>
  <li>Peterson lock satisfies
    <ul>
      <li>mutual exclusion</li>
      <li>starvation-freedom</li>
    </ul>
  </li>
  <li>Therefore
    <ul>
      <li>Peterson lock also satisfies deadlock-freedom</li>
    </ul>
  </li>
</ul>
<p>Nice!</p></section><section id="but-we-want-more-threads"><h2>But We Want More Threads!</h2>
<p><strong>Questions:</strong></p>
<ol>
  <li>What part of Peterson implementation generalizes easily to more threads?</li>
  <li>What part doesn’t generalize as easily?</li>
</ol>
<div style="margin-bottom: 12em"></div></section><section id="peterson-lock-code-again"><h2>Peterson Lock Code, Again</h2>
<pre><code class="language-java">class Peterson implements Lock {
    private boolean[] flag = new boolean[2];
	private int victim;
	
	public void lock () {
	   int i = ThreadID.get(); // get my ID, 0 or 1
	   int j = 1 - i;          // other thread's ID
	   
	   flag[i] = true;         // set my flag
	   victim = i;             // set myself to be victim
	   while (flag[j] &amp;&amp; victim == i) {
	       // wait
	   }
	}
	
	public void unlock () {
	    int i = ThreadID.get();
		flag[i] = false;
	}
}
</code></pre></section><section id="semantics-of-peterson-lock"><h2>Semantics of Peterson Lock</h2>
<ul>
  <li>
<code>flag</code> variable signals <em>intent</em> to enter CS
    <ul>
      <li>easily generalizes to more threads</li>
    </ul>
  </li>
  <li>
<code>victim</code> variable signals <em>priority</em> to enter CS
    <ul>
      <li>
<code>victim = me</code> means <code>you</code> have priority</li>
    </ul>
  </li>
  <li>For more threads
    <ul>
      <li>more victims?
        <ul>
          <li>how decide priority among victims?</li>
        </ul>
      </li>
      <li>how can this system be fair?</li>
    </ul>
  </li>
</ul></section><section id="lamports-idea-for-priority-i"><h2>Lamport’s Idea for Priority I</h2>
<p><img src="/assets/img/lamport-bakery/ticket-machine.jpg" alt="" width="50%"></p></section><section id="lamports-idea-for-priority-ii"><h2>Lamport’s Idea for Priority II</h2>
<p>After signalling intent to enter CS</p>
<ul>
  <li>Take a ticket
    <ul>
      <li>value of ticket is 1 more than max of others’ tickets</li>
      <li>thread <code>i</code> sets <code>label[i]</code> to ticket value</li>
    </ul>
  </li>
  <li>What is the problem with this?</li>
</ul>
<div style="margin-bottom: 12em"></div></section><section id="breaking-priority-ties"><h2>Breaking Priority Ties</h2>
<p>Two processes may see the same set of tickets and take same label:</p>
<ul>
  <li>have <code>label[i] == label[j]</code> for <code>i != j</code>
</li>
</ul>
<p><strong>Solution:</strong></p>
<p>Break ties by ID:</p>
<ul>
  <li>if <code>label[i] == label[j]</code> and <code>i &lt; j</code>, then <code>i</code> has priority</li>
</ul>
<p>Use <strong>lexicographic order</strong> on pairs <code>(label[i], i)</code></p></section><section id="question-about-tie-breaking"><h2>Question About Tie-breaking</h2>
<p>Is this process fair?</p>
<ul>
  <li>Seems we are <em>always</em> giving priority to thread <code>0</code>…</li>
</ul>
<div style="margin-bottom: 12em"></div></section><section id="lamports-bakery-algorithm"><h2>Lamport’s Bakery Algorithm</h2>
<p>Fields:</p>
<ul>
  <li>
<code>boolean[] flag</code>
    <ul>
      <li>
<code>flag[i] == true</code> indicates <code>i</code> would like enter CS</li>
    </ul>
  </li>
  <li>
<code>int[] label</code>
    <ul>
      <li>
<code>label[i]</code> indicates “ticket” number held by <code>i</code>
</li>
    </ul>
  </li>
</ul>
<p>Initialization:</p>
<ul>
  <li>set all <code>flag[i] = false</code>, <code>label[i] = 0</code>
</li>
</ul></section><section id="locking"><h2>Locking</h2>
<p>Locking Method:</p>
<pre><code class="language-java">public void lock () {
    int i = ThreadID.get();
    flag[i] = true;
    label[i] = max(label[0], ..., label[n-1]) + 1;
    while (!hasPriority(i)) {} // wait	
}
</code></pre>
<p>The method <code>hasPriority(i)</code> returns <code>true</code> if and only if there is no <code>k</code> such that</p>
<ul>
  <li>
<code>flag[k] == true</code> and</li>
  <li>either <code>label[k] &lt; label[i]</code> or <code>label[k] == label[i]</code> and <code>k &lt; i</code>
</li>
</ul></section><section id="unlocking"><h2>Unlocking</h2>
<p>Just lower your flag:</p>
<pre><code class="language-java">public void unlock() {
    flag[ThreadID.get()] = false;
}
</code></pre></section><section id="bakery-algorithm-guarantees"><h1>Bakery Algorithm Guarantees</h1></section><section id="bakery-algorithm-is-deadlock-free"><h2>Bakery Algorithm is Deadlock-Free</h2>
<pre><code class="language-java">public void lock () {
    int i = ThreadID.get();
    flag[i] = true;
    label[i] = max(label[0], ..., label[n-1]) + 1;
    while (!hasPriority(i)) {} // wait	
}
</code></pre>
<p>Why?</p>
<div style="margin-bottom: 12em"></div></section><section id="first-come-first-served-fcfs-property"><h2>First-come-first-served (FCFS) Property</h2>
<ul>
  <li>If:  $A$ writes to <code>label</code> before $B$ calls <code>lock()</code>,</li>
  <li>Then: $A$ enter CS before $B$.</li>
</ul>
<pre><code class="language-java">public void lock () {
    int i = ThreadID.get();
    flag[i] = true;
    label[i] = max(label[0], ..., label[n-1]) + 1;
    while (!hasPriority(i)) {} // wait	
}
</code></pre>
<p>Why?</p>
<div style="margin-bottom: 8em"></div></section><section id="bakery-algorithm-is-starvation-free"><h2>Bakery Algorithm is Starvation-Free</h2>
<p>Thread <code>i</code> calls <code>lock()</code>:</p>
<ul>
  <li>
<code>i</code> writes <code>label[i]</code>
</li>
  <li>By FCFS, subsequent calls to <code>lock()</code> by <code>j != i</code> have lower priority</li>
  <li>By deadlock-freedom every <code>k</code> ahead of <code>i</code> eventaully releases lock</li>
</ul>
<p>So:</p>
<ul>
  <li>
<code>i</code> eventually served</li>
</ul></section><section id="bakery-algorithm-satisfies-mutex"><h2>Bakery Algorithm Satisfies MutEx</h2>
<pre><code class="language-java">public void lock () {
    int i = ThreadID.get();
    flag[i] = true;
    label[i] = max(label[0], ..., label[n-1]) + 1;
    while (!hasPriority(i)) {} // wait	
}
</code></pre>
<p>Suppose not:</p>
<ul>
  <li>$A$ and $B$ concurrently in CS</li>
  <li>Assume: $(\mathrm{label}(A), A) &lt; (\mathrm{label}(B), B)$</li>
</ul></section><section id="proof-continued"><h2>Proof (Continued)</h2>
<p>Since $B$ entered CS:</p>
<ul>
  <li>Must have read
    <ul>
      <li>$(\mathrm{label}(B), B) &lt; (\mathrm{label}(A), A)$, or</li>
      <li>$\mathrm{flag}[A] == \mathrm{false}$</li>
    </ul>
  </li>
  <li>
    <p>Former can not happen: labels strictly increasing</p>
  </li>
  <li>So $B$ read $\mathrm{flag}[A] == \mathrm{false}$</li>
</ul></section><section id="compare-timelines"><h2>Compare Timelines!</h2>
<div style="margin-bottom: 18em"></div></section><section id="conclusion-2"><h2>Conclusion</h2>
<p>Lamport’s Bakery Algorithm:</p>
<ol>
  <li>Works for any number of threads</li>
  <li>Satisfies MutEx and starvation-freedom</li>
</ol></section><section id="question"><h2>Question</h2>
<p>Is the bakery algorithm <em>practical?</em></p>
<ul>
  <li>Maybe for few threads…</li>
  <li>But for many threads?
    <ul>
      <li>
<code>label</code> array contains $n$ indices</li>
      <li>must read all entries to set own <code>label</code>
</li>
      <li>costly if many threads!</li>
    </ul>
  </li>
  <li>Could we do better?</li>
</ul></section><section id="remarkably"><h2>Remarkably</h2>
<p>We cannot do better:</p>
<ul>
  <li>
    <p>If $n$ threads want to achieve mutual exclusion + deadlock-freedom, must have $n$ read/write registers (variables)</p>
  </li>
  <li>This is really bad if we have a lot of threads!
    <ul>
      <li>1,000 threads means each call to <code>lock()</code> requires 1,000s of reads</li>
      <li>each call to <code>hasPriority</code> requires either 1,000s of reads or a more advanced data structure</li>
    </ul>
  </li>
  <li>Things are messy!</li>
</ul></section><section id="a-way-around-the-bound"><h2>A Way Around the Bound</h2>
<ul>
  <li>
    <p>Argument relies crucially on fact that the <em>only</em> atomic operations are <code>read</code> and <code>write</code></p>
  </li>
  <li>
    <p>Modern computers offer more powerful atomic operations</p>
  </li>
  <li>In Java, <code>AtomicBoolean</code> class
    <ul>
      <li><code>getAndSet()</code></li>
      <li><code>compareAndSet()</code></li>
    </ul>
  </li>
  <li>We will discuss more later</li>
</ul></section><section id="up-next"><h2>Up Next</h2>
<p>Concurrent Objects!</p></section>
</div></div>


	  <script src="/assets/reveal.js-master/dist/reveal.js"></script>
	  <script src="/assets/reveal.js-master/plugin/math/math.js"></script>
	  <script src="/assets/reveal.js-master/plugin/zoom/zoom.js"></script>
	  <script src="/assets/reveal.js-master/plugin/notes/notes.js"></script>
	  <script src="/assets/reveal.js-master/plugin/search/search.js"></script>
	  <script src="/assets/reveal.js-master/plugin/markdown/markdown.js"></script>
	  <script src="/assets/reveal.js-master/plugin/highlight/highlight.js"></script>
	  <script>
	    

	    // Also available as an ES module, see:
	    // https://revealjs.com/initialization/
	    Reveal.initialize({
		controls: false,
		progress: true,
		center: true,
		hash: true,
		transition: 'none',
		math: {
		    config: 'TeX-AMS_HTML-full',
		    TeX: {
			Macros: {
			    R: '\\mathbb{R}',
			    set: [ '\\left\\{#1 \\; ; \\; #2\\right\\}', 2 ]
			}
		    }
		},


		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight, RevealMath ]
	    });

	  </script>

	</body>
</html>
	  

<!-- <\!-- load the reveal.js css & js (assuming you've put it in assets/)-\-> -->
<!-- <link -->
<!--   rel="stylesheet" -->
<!--   href="/assets/reveal.js-master/css/reveal.scss" -->
<!-- /> -->
<!-- <link -->
<!--   rel="stylesheet" -->
<!--   href="/assets/reveal.js-master/css/theme/source/white.scss" -->
<!-- /> -->
<!-- <script -->
<!--   src="/assets/reveal.js-master/js/reveal.js" -->
<!--   type="text/javascript" -->
<!-- ></script> -->

<!-- <\!-- configure the presentation, (you can tweak options to suit) -\-> -->
<!-- <script> -->
<!--   Reveal.initialize({ -->
<!--     // Display presentation control arrows -->
<!--     controls: false, -->

<!--     // Help the user learn the controls by providing hints, for example by -->
<!--     // bouncing the down arrow when they first encounter a vertical slide -->
<!--     controlsTutorial: false, -->

<!--     // Determines where controls appear, "edges" or "bottom-right" -->
<!--     controlsLayout: "bottom-right", -->

<!--     // Visibility rule for backwards navigation arrows; "faded", "hidden" -->
<!--     // or "visible" -->
<!--     controlsBackArrows: "faded", -->

<!--     // Display a presentation progress bar -->
<!--     progress: true, -->

<!--     // Display the page number of the current slide -->
<!--     slideNumber: false, -->

<!--     // Push each slide change to the browser history -->
<!--     history: false, -->

<!--     // Enable keyboard shortcuts for navigation -->
<!--     keyboard: true, -->

<!--     // Enable the slide overview mode -->
<!--     overview: true -->
<!--   }); -->
<!-- </script> -->
