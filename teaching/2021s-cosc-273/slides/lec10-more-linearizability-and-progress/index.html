<!doctype html>
<html lang="en">
	<head>

	  <meta name="viewport" content="width=device-width, initial-scale=1.0">
	  <meta charset="utf-8">

		<link rel="stylesheet" href="/assets/reveal.js-master/dist/reset.css">
		<link rel="stylesheet" href="/assets/reveal.js-master/dist/reveal.css">
		<link rel="stylesheet" href="/assets/css/condensation.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="/assets/reveal.js-master/plugin/highlight/monokai.css" id="highlight-theme">
		<link href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700" rel="stylesheet">

	</head>

	<body>


	  <!-- this is where the reveailfy filter gets applied -->
	  <div class="reveal"><div class="slides">


































































<!-- # Progress Conditions -->

<!-- ## Is Nonblocking Property Practical? -->

<!-- Nonblocking property $\implies$ *existence* of consistent response to pending method calls -->

<!-- - Does not ensure that such a response can be *found* easily -->

<!-- <div style="margin-bottom: 8em"></div> -->

<!-- ## Scheduler -->

<!-- Given a set of (concurrent) method calls a **scheduler** chooses sequence of methods that make steps -->

<!-- - in computers, OS is typically scheduler -->
<!-- - scheduler may be fair, may not be -->
<!-- - want progress guarantees independent of scheduler -->

<!-- <div style="margin-bottom: 6em"></div> -->

<!-- ## Nonblocking Progress Conditions -->

<!-- Conditions for implementations: -->

<!-- - **Wait-freedom**: pending method invocation always completes in a finite number of steps -->

<!-- <div style="margin-bottom: 6em"></div> -->

<!-- - **Lock-freedom**: among all pending method calls, some method completes in a finite number of steps -->

<!-- <div style="margin-bottom: 6em"></div> -->

<!-- ## Question -->

<!-- Is `TwoCounter` lock-fee? Wait-free? -->

<!-- ```java -->
<!-- public class TwoCounter { -->
<!--     int[] counts = new int[2]; -->

<!--     public void increment (int amt) { -->
<!--         int i = ThreadID.get(); // thread IDs are 0 and 1 -->
<!--         int count = counts[i]; -->
<!--         counts[i] = count + amt;		 -->
<!--     } -->

<!--     public int read () { -->
<!--         int count = counts[0]; -->
<!--         count = count + counts[1]; -->
<!--         return count; -->
<!--     }	 -->
<!-- } -->
<!-- ``` -->

<!-- <div style="margin-bottom: 6em"></div> -->

<!-- ## An Atomic Primitive -->

<!-- `AtomicInteger` class: -->

<!-- ```java -->
<!-- boolean compareAndSet(int expectedValue, int newValue); -->
<!-- ``` -->

<!-- Specification: -->

<!-- - if `ai`'s value is `expectedValue`, then -->
<!--     + after call, `ai`'s value is `newValue` -->
<!-- 	+ method returns `true` -->
<!-- - if `ai`'s value is not `expectedValue`, then -->
<!--     + after call, `ai`'s value is unchanged -->
<!-- 	+ method returns `false` -->

<!-- ## A Silly Counter -->

<!-- ```java -->
<!-- public class SillyCounter { -->

<!--     AtomicInteger ai = new AtomicInteger(0); -->

<!--     public void increment (int amt) { -->
<!--         int val = ai.get(); -->
<!--         while (!ai.compareAndSet(val, val + amt)) { -->
<!--             val = ai.get(); -->
<!--         } -->
<!--     } -->

<!--     public int read () { -->
<!--         return ai.get(); -->
<!--     } -->

<!-- } -->
<!-- ``` -->

<!-- ## Does `SillyCounter` Work? -->

<!-- ```java -->
<!-- public class SillyCounter { -->

<!--     AtomicInteger ai = new AtomicInteger(0); -->

<!--     public void increment (int amt) { -->
<!--         int val = ai.get(); -->
<!--         while (!ai.compareAndSet(val, val + amt)) { -->
<!--             val = ai.get(); -->
<!--         } -->
<!--     } -->

<!--     public int read () { -->
<!--         return ai.get(); -->
<!--     } -->

<!-- } -->
<!-- ``` -->

<!-- <div style="margin-bottom: 8em"></div> -->

<!-- ## Is `SillyCounter` Lock-free? -->

<!-- ```java -->
<!--     public void increment (int amt) { -->
<!--         int val = ai.get(); -->
<!--         while (!ai.compareAndSet(val, val + amt)) { -->
<!--             val = ai.get(); -->
<!--         } -->
<!--     } -->
<!-- ``` -->

<!-- <div style="margin-bottom: 12em"></div> -->

<!-- ## Is `SillyCounter` Wait-free? -->

<!-- ```java -->
<!--     public void increment (int amt) { -->
<!--         int val = ai.get(); -->
<!--         while (!ai.compareAndSet(val, val + amt)) { -->
<!--             val = ai.get(); -->
<!--         } -->
<!--     } -->
<!-- ``` -->

<!-- <div style="margin-bottom: 12em"></div> -->

<!-- ## Properties of Nonblocking Progress -->

<!-- - Progress is guaranteed even if some thread stalls -->
<!--     + e.g., scheduler stops scheduling a thread's method call -->
<!-- - Wait-freedom gives *maximal progress* -->
<!-- - Lock-freedom gives *minimal progress* -->
<!--     + starvation can still occur -->
<!-- - Actual progress depends on *scheduler* -->
<!--     + determines which threads make steps -->

<!-- <div style="margin-bottom: 4em"></div> -->

<!-- ## Blocking Progress Conditions -->

<!-- - **starvation-free**: whenever *all* pending methods take steps, *every* method call completes in a finite number of steps -->
<!--     + maximal (blocking) progress -->

<!-- <div style="margin-bottom: 6em"></div> -->

<!-- - **deadlock-free**: whenever *all* pending method calls take steps, *some* method call completes in a finite number of steps -->
<!--     + minimal (blocking) progress -->

<!-- <div style="margin-bottom: 6em"></div> -->

<!-- ## Blocking vs Nonblocking Progess -->

<!-- Nonblocking progress -->

<!-- - guarantees progress for any scheduler -->
<!-- - valid even if a process crashes -->

<!-- <div style="margin-bottom: 4em"></div> -->

<!-- Blocking progress -->

<!-- - progress only guaranteed for *fair* schedulers -->
<!-- - if a process crashes, progress not guaranteed -->

<!-- <div style="margin-bottom: 4em"></div> -->

<!-- ## Progress and Correctness Conditions are Indpendent -->

<!-- - Can have a data structure that is... -->
<!--     + ...sequentially consistent and wait-free -->
<!-- 	+ ...linearizable and lock-free -->
<!-- 	+ ...sequentially consistent and deadlock-free -->
<!-- 	+ ... -->

<!-- - Different implementations have different trade-offs -->

<!-- - Which implementation is best depends on application: -->
<!--     + how much synchronization is required? -->
<!-- 	    + how frequently is contention expected? -->
<!-- 	+ what correctness guarantee is required? -->

<!-- ## Coming Up -->

<!-- Implementations! -->

<!-- - locks -->
<!-- - data structures -->

<section id="lecture-10-more-linearizability-and-progress"><h1>Lecture 10: More Linearizability and Progress</h1></section><section id="overview"><h2>Overview</h2>
<ol>
  <li>Counter, Revisited</li>
  <li>Progress Condiditions</li>
</ol></section><section id="note-on-pixels-and-points"><h2>Note on Pixels and Points</h2>
<div style="margin-bottom: 18em"></div></section><section id="counter-revisited"><h1>Counter, Revisited</h1></section><section id="recall"><h2>Recall</h2>
<p>A concurrent execution is <strong>linearizable</strong> if:</p>
<ul>
  <li>exists a linearization point in each method call such that execution is consistent with sequential execution where method calls occur in order of corresponding linearization points</li>
</ul>
<p>An <em>implementation</em> of an object is linearizable if:</p>
<ul>
  <li>it guarantees every execution is linearizable</li>
</ul></section><section id="a-bad-counter"><h2>A Bad Counter</h2>
<pre><code class="language-java">public class Counter {
    int count = 0;
    
    public void increment () {
        ++count;
    }
    
    public int read () {
        return count;
    }
}
</code></pre>
<p>Why is this bad with multiple threads, even if read/write operations are atomic?</p>
<div style="margin-bottom: 8em"></div></section><section id="a-better-counter"><h2>A Better Counter?</h2>
<p>For two threads:</p>
<pre><code class="language-java">public class TwoCounter {
    int[] counts = new int[2];
	
    public void increment (int amt) {
        int i = ThreadID.get(); // thread IDs are 0 and 1
        int count = counts[i];
        counts[i] = count + amt;		
    }
	
    public int read () {
        int count = counts[0];
        count = count + counts[1];
        return count;
    }	
}
</code></pre>
<p>Is this better?</p></section><section id="download-the-worksheet"><h2>Download the Worksheet</h2>
<ul>
  <li><a href="https://docs.google.com/document/d/19rbzXGILiFejnj2L-7qXl6xFqTh0Ne3HEWfOpOJQZT0/edit?usp=sharing"><strong>More <code>Counter</code> Examples</strong></a></li>
</ul></section><section id="is-twocounter-linearizable"><h2>Is <code>TwoCounter</code> Linearizable?</h2>
<pre><code class="language-java">public class TwoCounter {
    int[] counts = new int[2];
	
    public void increment (int amt) {
        int i = ThreadID.get(); // thread IDs are 0 and 1
        int count = counts[i];
        counts[i] = count + amt;		
    }
	
    public int read () {
        int count = counts[0];
        count = count + counts[1];
        return count;
    }	
}
</code></pre>
<div style="margin-bottom: 6em"></div></section><section id="more-threads"><h2>More Threads!</h2>
<pre><code class="language-java">public class ThreeCounter {
    int[] counts = new int[3];
	
    public void increment (int amt) {
        int i = ThreadID.get(); // thread IDs are 0, 1, and 2
        int count = counts[i];
        counts[i] = count + amt;		
    }
	
    public int read () {
        int count = counts[0];
        count = count + counts[1];
        count = count + counts[2];		
        return count;
    }	
}
</code></pre>
<p>Is <code>ThreeCounter</code> Linearizable?</p>
<div style="margin-bottom: 4em"></div></section><section id="is-threecounter-linearizable"><h2>Is <code>ThreeCounter</code> Linearizable?</h2>
<div style="margin-bottom: 18em"></div></section><section id="conclusion"><h2>Conclusion</h2>
<ul>
  <li>Linearizability is…
    <ul>
      <li>…a reasonable correctness condition</li>
      <li>…nonblocking</li>
      <li>…compositional</li>
      <li>…subtle to reason about</li>
    </ul>
  </li>
</ul>
<p>You will work through more problems on linearizability on Homework 3 and Quiz 3.</p></section>
</div></div>


	  <script src="/assets/reveal.js-master/dist/reveal.js"></script>
	  <script src="/assets/reveal.js-master/plugin/math/math.js"></script>
	  <script src="/assets/reveal.js-master/plugin/zoom/zoom.js"></script>
	  <script src="/assets/reveal.js-master/plugin/notes/notes.js"></script>
	  <script src="/assets/reveal.js-master/plugin/search/search.js"></script>
	  <script src="/assets/reveal.js-master/plugin/markdown/markdown.js"></script>
	  <script src="/assets/reveal.js-master/plugin/highlight/highlight.js"></script>
	  <script>
	    

	    // Also available as an ES module, see:
	    // https://revealjs.com/initialization/
	    Reveal.initialize({
		controls: false,
		progress: true,
		center: true,
		hash: true,
		transition: 'none',
		math: {
		    config: 'TeX-AMS_HTML-full',
		    TeX: {
			Macros: {
			    R: '\\mathbb{R}',
			    set: [ '\\left\\{#1 \\; ; \\; #2\\right\\}', 2 ]
			}
		    }
		},


		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight, RevealMath ]
	    });

	  </script>

	</body>
</html>
	  

<!-- <\!-- load the reveal.js css & js (assuming you've put it in assets/)-\-> -->
<!-- <link -->
<!--   rel="stylesheet" -->
<!--   href="/assets/reveal.js-master/css/reveal.scss" -->
<!-- /> -->
<!-- <link -->
<!--   rel="stylesheet" -->
<!--   href="/assets/reveal.js-master/css/theme/source/white.scss" -->
<!-- /> -->
<!-- <script -->
<!--   src="/assets/reveal.js-master/js/reveal.js" -->
<!--   type="text/javascript" -->
<!-- ></script> -->

<!-- <\!-- configure the presentation, (you can tweak options to suit) -\-> -->
<!-- <script> -->
<!--   Reveal.initialize({ -->
<!--     // Display presentation control arrows -->
<!--     controls: false, -->

<!--     // Help the user learn the controls by providing hints, for example by -->
<!--     // bouncing the down arrow when they first encounter a vertical slide -->
<!--     controlsTutorial: false, -->

<!--     // Determines where controls appear, "edges" or "bottom-right" -->
<!--     controlsLayout: "bottom-right", -->

<!--     // Visibility rule for backwards navigation arrows; "faded", "hidden" -->
<!--     // or "visible" -->
<!--     controlsBackArrows: "faded", -->

<!--     // Display a presentation progress bar -->
<!--     progress: true, -->

<!--     // Display the page number of the current slide -->
<!--     slideNumber: false, -->

<!--     // Push each slide change to the browser history -->
<!--     history: false, -->

<!--     // Enable keyboard shortcuts for navigation -->
<!--     keyboard: true, -->

<!--     // Enable the slide overview mode -->
<!--     overview: true -->
<!--   }); -->
<!-- </script> -->
