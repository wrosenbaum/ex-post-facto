<!doctype html>
<html lang="en">
	<head>

	  <meta name="viewport" content="width=device-width, initial-scale=1.0">
	  <meta charset="utf-8">

		<link rel="stylesheet" href="/assets/reveal.js-master/dist/reset.css">
		<link rel="stylesheet" href="/assets/reveal.js-master/dist/reveal.css">
		<link rel="stylesheet" href="/assets/css/condensation.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="/assets/reveal.js-master/plugin/highlight/monokai.css" id="highlight-theme">
		<link href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700" rel="stylesheet">

	</head>

	<body>


	  <!-- this is where the reveailfy filter gets applied -->
	  <div class="reveal"><div class="slides">











































































































































































<section id="lab-week-12-sorting-networks"><h1>Lab Week 12: Sorting Networks</h1></section><section id="outline"><h2>Outline</h2>
<ol>
  <li>Simple Sorting Algorithms</li>
  <li>Sorting Networks</li>
  <li>Sorting Activity</li>
</ol></section><section id="last-time"><h2>Last Time</h2>
<p>Sorting by Divide and Conquer</p>
<ul>
  <li>Merge sort
    <ol>
      <li>sort left half</li>
      <li>sort left half</li>
      <li>merge sorted halves</li>
    </ol>
  </li>
  <li>Quicksort
    <ol>
      <li>pick pivot</li>
      <li>split according to pivot
        <ul>
          <li>left half less than pivot</li>
          <li>right half at least pivot</li>
        </ul>
      </li>
      <li>sort left half</li>
      <li>sort right half</li>
    </ol>
  </li>
</ul></section><section id="sorting-networks"><h2>Sorting Networks</h2>
<p>Another view of sorting in parallel</p></section><section id="insertion-sort-revisited"><h2>Insertion Sort, Revisited</h2>
<pre><code class="language-java">for (int i = 1; i &lt; data.length; ++i) {
    for (int j = i; j &gt; 0; --j) {
        if (data[j-1] &gt; data[j]) {
            swap(data, j-1, j)		
        }
    }
}
</code></pre>
<div style="margin-bottom: 12em"></div></section><section id="appealing-features-of-insertion-sort"><h2>Appealing Features of Insertion Sort</h2>
<pre><code class="language-java">for (int i = 1; i &lt; data.length; ++i) {
    for (int j = i; j &gt; 0; --j) {
        if (data[j-1] &gt; data[j]) {
            swap(data, j-1, j)		
        }
    }
}
</code></pre>
<ol>
  <li>Only modifications are (adjacent) swaps
    <ul>
      <li>sorting is <em>in place</em>
</li>
    </ul>
  </li>
  <li>Access pattern is independent of input
    <ul>
      <li>inputs always read/compared in same order</li>
      <li>only difference between execution is outcomes of swaps</li>
    </ul>
  </li>
</ol></section><section id="comparators-visualizing-swaps"><h2>Comparators: Visualizing Swaps</h2>
<pre><code class="language-java">        if (data[i] &gt; data[j]) {
            swap(data, i, j)
        }

</code></pre>
<p><img src="/assets/img/sorting-networks/comparator.png" alt="" width="75%"></p></section><section id="comparator-swap"><h2>Comparator Swap</h2>
<p><img src="/assets/img/sorting-networks/comparator-swap.png" alt="" width="100%"></p></section><section id="comparator-no-swap"><h2>Comparator No Swap</h2>
<p><img src="/assets/img/sorting-networks/comparator-no-swap.png" alt="" width="100%"></p></section><section id="sorting-array-of-two-elements"><h2>Sorting Array of Two Elements</h2>
<p><img src="/assets/img/sorting-networks/comparator-2.png" alt="" width="100%"></p></section><section id="insertion-sort"><h2>Insertion Sort</h2>
<pre><code class="language-java">for (int i = 1; i &lt; data.length; ++i) {
    for (int j = i; j &gt; 0; --j) {
        if (data[j-1] &gt; data[j]) {
            swap(data, j-1, j)		
        }
    }
}
</code></pre>
<p><img src="/assets/img/sorting-networks/insertion-sort-0.png" alt="" width="75%"></p></section><section id="insertion-sort-i--1"><h2>Insertion Sort: <code>i = 1</code>
</h2>
<p><img src="/assets/img/sorting-networks/insertion-sort-1.png" alt="" width="100%"></p></section><section id="insertion-sort-i--2"><h2>Insertion Sort: <code>i = 2</code>
</h2>
<p><img src="/assets/img/sorting-networks/insertion-sort-2.png" alt="" width="100%"></p></section><section id="insertion-sort-i--3"><h2>Insertion Sort: <code>i = 3</code>
</h2>
<p><img src="/assets/img/sorting-networks/insertion-sort-3.png" alt="" width="100%"></p></section><section id="which-operations-can-be-parallelized"><h2>Which Operations can be Parallelized?</h2>
<p><img src="/assets/img/sorting-networks/insertion-sort-3.png" alt="" width="100%"></p></section><section id="parallelism"><h2>Parallelism</h2>
<p><img src="/assets/img/sorting-networks/insertion-sort-parallel-1.png" alt="" width="100%"></p></section><section id="cleaner-parallel-representation"><h2>Cleaner Parallel Representation</h2>
<p><img src="/assets/img/sorting-networks/insertion-sort-parallel-2.png" alt="" width="100%"></p></section><section id="depth"><h2>Depth</h2>
<p><img src="/assets/img/sorting-networks/insertion-sort-parallel-3.png" alt="" width="100%"></p></section><section id="insertion-sort-larger-instance"><h2>Insertion Sort: Larger Instance</h2>
<p><img src="/assets/img/sorting-networks/insertion-sort-large-1.png" alt="" width="100%"></p></section><section id="done-in-parallel"><h2>Done In Parallel?</h2>
<p><img src="/assets/img/sorting-networks/insertion-sort-large-1.png" alt="" width="100%"></p></section><section id="done-in-parallel-1"><h2>Done In Parallel!</h2>
<p><img src="/assets/img/sorting-networks/insertion-sort-large-2.png" alt="" width="100%"></p></section><section id="cleaned-up"><h2>Cleaned Up</h2>
<p><img src="/assets/img/sorting-networks/insertion-sort-large-3.png" alt="" width="100%"></p></section><section id="parallel-depth"><h2>Parallel Depth?</h2>
<p><img src="/assets/img/sorting-networks/insertion-sort-large-4.png" alt="" width="100%"></p></section><section id="bubble-sort"><h2>Bubble Sort</h2>
<p>Consider:</p>
<pre><code class="language-java">for (int m = data.length - 1; m &gt; 0; --m) {
    for (int i = 0; i &lt; m; ++i) {
        if (data[i] &gt; data[i+1]) {
            swap(data, i, i+1)		
        }
    }
}
</code></pre>
<p>Can we make a sorting network corresponding to bubble sort?</p>
<div style="margin-bottom: 8em"></div></section><section id="bubble-sort-m--6"><h2>Bubble Sort: <code>m = 6</code>
</h2>
<p><img src="/assets/img/sorting-networks/bubble-sort-1.png" alt="" width="100%"></p></section><section id="bubble-sort-m--5"><h2>Bubble Sort: <code>m = 5</code>
</h2>
<p><img src="/assets/img/sorting-networks/bubble-sort-2.png" alt="" width="100%"></p></section><section id="bubble-sort-m--4"><h2>Bubble Sort: <code>m = 4</code>
</h2>
<p><img src="/assets/img/sorting-networks/bubble-sort-3.png" alt="" width="100%"></p></section><section id="bubble-sort-m--3"><h2>Bubble Sort: <code>m = 3</code>
</h2>
<p><img src="/assets/img/sorting-networks/bubble-sort-4.png" alt="" width="100%"></p></section><section id="bubble-sort-m--2"><h2>Bubble Sort: <code>m = 2</code>
</h2>
<p><img src="/assets/img/sorting-networks/bubble-sort-5.png" alt="" width="100%"></p></section><section id="bubble-sort-network"><h2>Bubble Sort Network</h2>
<p><img src="/assets/img/sorting-networks/bubble-sort-6.png" alt="" width="100%"></p></section><section id="bubble-sort-parallelized"><h2>Bubble Sort Parallelized?</h2>
<p><img src="/assets/img/sorting-networks/bubble-sort-6.png" alt="" width="100%"></p></section><section id="does-it-look-familiar"><h2>Does it Look Familiar?</h2>
<p><img src="/assets/img/sorting-networks/bubble-sort-7.png" alt="" width="100%"></p></section><section id="huh"><h2>Huh</h2>
<ul>
  <li>Insertion sort and bubble sort perform precisely same operations
    <ul>
      <li>only differ in the order in which comparisons are made</li>
    </ul>
  </li>
  <li>
    <p>When fuly parallelized, both are same sorting network</p>
  </li>
  <li>Parallel versions are reasonably efficient
    <ul>
      <li>depth $2 (n - 1) - 1 = 2 n - 3$</li>
    </ul>
  </li>
</ul></section><section id="applications"><h2>Applications</h2>
<ul>
  <li>Sorting networks can be efficiently implemented in hardware
    <ul>
      <li>can sort fixed number of items much faster than software sorting</li>
    </ul>
  </li>
  <li>Depth corresponds to latency
    <ul>
      <li>smaller depth = faster computations</li>
    </ul>
  </li>
</ul></section><section id="activity"><h2>Activity</h2>
<p>Find a minimum depth sorting networks for small $n$!</p></section><section id="minimum-depth-for-n--4"><h2>Minimum Depth for $n = 4$?</h2>
<div style="margin-bottom: 18em"></div></section><section id="smaller-depth-for-n--6"><h2>Smaller Depth for $n = 6$?</h2>
<div style="margin-bottom: 18em"></div></section><section id="current-state"><h2>Current State</h2>
<p>What is known:</p>
<ul>
  <li>Optimal depth sorting networks for $n \leq 17$</li>
</ul>
<p>What is not known:</p>
<ul>
  <li>Optimal depth sorting networks for $n \geq 18$</li>
</ul></section>
</div></div>


	  <script src="/assets/reveal.js-master/dist/reveal.js"></script>
	  <script src="/assets/reveal.js-master/plugin/math/math.js"></script>
	  <script src="/assets/reveal.js-master/plugin/zoom/zoom.js"></script>
	  <script src="/assets/reveal.js-master/plugin/notes/notes.js"></script>
	  <script src="/assets/reveal.js-master/plugin/search/search.js"></script>
	  <script src="/assets/reveal.js-master/plugin/markdown/markdown.js"></script>
	  <script src="/assets/reveal.js-master/plugin/highlight/highlight.js"></script>
	  <script>
	    

	    // Also available as an ES module, see:
	    // https://revealjs.com/initialization/
	    Reveal.initialize({
		controls: false,
		progress: true,
		center: true,
		hash: true,
		transition: 'none',
		math: {
		    config: 'TeX-AMS_HTML-full',
		    TeX: {
			Macros: {
			    R: '\\mathbb{R}',
			    set: [ '\\left\\{#1 \\; ; \\; #2\\right\\}', 2 ]
			}
		    }
		},


		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight, RevealMath ]
	    });

	  </script>

	</body>
</html>
	  

<!-- <\!-- load the reveal.js css & js (assuming you've put it in assets/)-\-> -->
<!-- <link -->
<!--   rel="stylesheet" -->
<!--   href="/assets/reveal.js-master/css/reveal.scss" -->
<!-- /> -->
<!-- <link -->
<!--   rel="stylesheet" -->
<!--   href="/assets/reveal.js-master/css/theme/source/white.scss" -->
<!-- /> -->
<!-- <script -->
<!--   src="/assets/reveal.js-master/js/reveal.js" -->
<!--   type="text/javascript" -->
<!-- ></script> -->

<!-- <\!-- configure the presentation, (you can tweak options to suit) -\-> -->
<!-- <script> -->
<!--   Reveal.initialize({ -->
<!--     // Display presentation control arrows -->
<!--     controls: false, -->

<!--     // Help the user learn the controls by providing hints, for example by -->
<!--     // bouncing the down arrow when they first encounter a vertical slide -->
<!--     controlsTutorial: false, -->

<!--     // Determines where controls appear, "edges" or "bottom-right" -->
<!--     controlsLayout: "bottom-right", -->

<!--     // Visibility rule for backwards navigation arrows; "faded", "hidden" -->
<!--     // or "visible" -->
<!--     controlsBackArrows: "faded", -->

<!--     // Display a presentation progress bar -->
<!--     progress: true, -->

<!--     // Display the page number of the current slide -->
<!--     slideNumber: false, -->

<!--     // Push each slide change to the browser history -->
<!--     history: false, -->

<!--     // Enable keyboard shortcuts for navigation -->
<!--     keyboard: true, -->

<!--     // Enable the slide overview mode -->
<!--     overview: true -->
<!--   }); -->
<!-- </script> -->
