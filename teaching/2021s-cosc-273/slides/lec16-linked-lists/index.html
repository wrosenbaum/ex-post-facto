<!doctype html>
<html lang="en">
	<head>

	  <meta name="viewport" content="width=device-width, initial-scale=1.0">
	  <meta charset="utf-8">

		<link rel="stylesheet" href="/assets/reveal.js-master/dist/reset.css">
		<link rel="stylesheet" href="/assets/reveal.js-master/dist/reveal.css">
		<link rel="stylesheet" href="/assets/css/condensation.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="/assets/reveal.js-master/plugin/highlight/monokai.css" id="highlight-theme">
		<link href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700" rel="stylesheet">

	</head>

	<body>


	  <!-- this is where the reveailfy filter gets applied -->
	  <div class="reveal"><div class="slides">































































































































































































<section id="lecture-16-concurrent-linked-lists"><h1>Lecture 16: Concurrent Linked Lists</h1></section><section id="overview"><h2>Overview</h2>
<ol>
  <li>Lab 04 Tips</li>
  <li>
<code>Set</code> as a Linked List</li>
  <li>Synchronization Philosophies</li>
  <li>Coarse-grained Linked List</li>
  <li>Fine-grained Linked List</li>
  <li>Optimistic Linked List</li>
</ol></section><section id="lab-04-tips"><h1>Lab 04 Tips</h1></section><section id="prime-tasks"><h2>Prime Tasks</h2>
<p>Suggested structure:</p>
<ol>
  <li>Compute small primes (up to <code>Math.sqrt(MAX)</code>)
    <ul>
      <li>use <code>Primes.getPrimesUpTo(int max)</code>
</li>
    </ul>
  </li>
  <li>Use small primes and SoE to find rest of primes
    <ul>
      <li>consider a block <code>[n, n + k]</code> of numbers from <code>n</code> to <code>n + k</code>
</li>
      <li>for each small prime <code>p</code>, remove multiples of <code>p</code> from <code>[n, n + k]</code>
</li>
      <li>remaining numbers are prime</li>
    </ul>
  </li>
  <li>Write primes from step 2 in order to <code>primes</code> array</li>
</ol>
<p>Have a dedicated thread for step 3; use several threads to perform step 2 in parallel</p></section><section id="prime-tasks-in-pictures"><h2>Prime Tasks in Pictures</h2>
<div style="margin-bottom: 18em"></div></section><section id="performance-optimizations"><h2>Performance Optimizations</h2>
<ol>
  <li>Use reasonably small objects
    <ul>
      <li>several smaller tasks/arrays are better than few larger ones</li>
      <li>arrays should fit in low-level cache</li>
    </ul>
  </li>
  <li>Minimize sharing of objects
    <ul>
      <li>each object should be written by one thread, and read by at most one other thread</li>
      <li>think of “passing” completed tasks from producer to consumer</li>
      <li>limit concurrent access</li>
    </ul>
  </li>
</ol></section><section id="a-set"><h2>A <code>Set</code>
</h2>
<p>A <code>Set</code> of elements:</p>
<ul>
  <li>store a collection of <em>distinct</em> elements</li>
  <li>
<code>add</code> an element
    <ul>
      <li>no effect if element already there</li>
    </ul>
  </li>
  <li>
<code>remove</code> an element
    <ul>
      <li>no effect if not present</li>
    </ul>
  </li>
  <li>check if set <code>contains</code> an element</li>
</ul></section><section id="an-interface"><h2>An Interface</h2>
<pre><code class="language-java">public interface SimpleSet&lt;T&gt; {
    /*
     * Add an element to the SimpleSet. Returns true if the element
     * was not already in the set.
     */
    boolean add(T x);

    /*
     * Remove an element from the SimpleSet. Returns true if the
     * element was previously in the set.
     */
    boolean remove(T x);

    /*
     * Test if a given element is contained in the set.
     */
    boolean contains(T x);
}
</code></pre></section><section id="implementing-simpleset"><h2>Implementing <code>SimpleSet</code>
</h2>
<p>Store elements in a linked list of nodes</p>
<ul>
  <li>Each <code>Node</code> stores:
    <ul>
      <li>reference to the stored object</li>
      <li>reference to the next <code>Node</code>
</li>
      <li>a <em>key</em> associated with the object
        <ul>
          <li>use hash code of object</li>
          <li>keys can be sorted</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>The list stores
    <ul>
      <li>reference to <code>head</code> node</li>
      <li>a <code>tail</code> node</li>
      <li>
<code>head</code> and <code>tail</code> have min and max key values</li>
    </ul>
  </li>
</ul></section><section id="our-goals"><h2>Our Goals</h2>
<ol>
  <li>Correctness, safety, liveness
    <ul>
      <li>linearizability</li>
      <li>deadlock-freedom</li>
      <li>starvation-freedom?</li>
      <li>nonblocking???</li>
    </ul>
  </li>
  <li>Performance
    <ul>
      <li>parallelism?</li>
    </ul>
  </li>
</ol></section><section id="synchronization-philosophies"><h1>Synchronization Philosophies</h1></section><section id="synchronization-philosophies-1"><h2>Synchronization Philosophies</h2>
<ol>
  <li>Coarse-Grained
    <ul>
      <li>lock whole data structure for every operation</li>
    </ul>
  </li>
  <li>Fine-Grained
    <ul>
      <li>only lock what is needed to avoid disaster</li>
    </ul>
  </li>
  <li>Optimisitc
    <ul>
      <li>don’t lock anything to read</li>
      <li>lock to modify</li>
    </ul>
  </li>
  <li>Lazy
    <ul>
      <li>use “logical” removal</li>
      <li>only use locks occasionally</li>
    </ul>
  </li>
  <li>Nonblocking
    <ul>
      <li>use atomics, not locks!</li>
    </ul>
  </li>
</ol></section><section id="coarse-grained-linked-list"><h1>Coarse-grained Linked List</h1></section><section id="coarse-grained-linked-list-1"><h2>Coarse-grained Linked List</h2>
<p>One lock for whole data structure</p>
<p>For any operation:</p>
<ol>
  <li>Lock entire list</li>
  <li>Perform operation</li>
  <li>Unlock list</li>
</ol></section><section id="coarse-grained-list-figure"><h2>Coarse-grained List Figure</h2>
<p><img src="/assets/img/concurrent-lists/coarse-list.png" alt="" width="100%"></p></section><section id="add-item-with-key-5"><h2>Add <code>item</code> with Key <code>5</code>
</h2>
<p><img src="/assets/img/concurrent-lists/coarse-list.png" alt="" width="100%"></p></section><section id="step-1-lock-list"><h2>Step 1: Lock List</h2>
<p><img src="/assets/img/concurrent-lists/coarse-list.png" alt="" width="100%"></p></section><section id="step-2-find-correct-location"><h2>Step 2: Find Correct Location</h2>
<p><img src="/assets/img/concurrent-lists/coarse-list.png" alt="" width="100%"></p></section><section id="step-3-do-insertion"><h2>Step 3: Do Insertion</h2>
<p><img src="/assets/img/concurrent-lists/coarse-list.png" alt="" width="100%"></p></section><section id="step-4-unlock-list"><h2>Step 4: Unlock List</h2>
<p><img src="/assets/img/concurrent-lists/coarse-list.png" alt="" width="100%"></p></section><section id="in-code"><h2>In Code</h2>
<ul>
  <li>Look at implementation</li>
  <li>Test performance</li>
  <li>This is our baseline!</li>
</ul></section><section id="fine-grained-linked-list"><h1>Fine-grained Linked List</h1></section><section id="fine-grained-linked-list-1"><h2>Fine-grained Linked List</h2>
<p>One lock per node</p>
<p>For any operation:</p>
<ol>
  <li>Store <code>curr</code>, <code>pred</code> (initialized to head)
    <ul>
      <li>lock <code>pred</code>
</li>
    </ul>
  </li>
  <li>Hand-over-hand locking:
    <ul>
      <li>lock <code>curr = pred.next</code>
</li>
      <li>unlock <code>pred</code>
</li>
      <li>set <code>pred = curr</code>
</li>
      <li>repeat until correct location found</li>
    </ul>
  </li>
  <li>Perform operation</li>
  <li>Release locks</li>
</ol></section><section id="fine-grained-list-figure"><h2>Fine-grained List Figure</h2>
<p><img src="/assets/img/concurrent-lists/fine-list.png" alt="" width="100%"></p></section><section id="add-item-with-key-5-1"><h2>Add <code>item</code> with Key <code>5</code>
</h2>
<p><img src="/assets/img/concurrent-lists/fine-list.png" alt="" width="100%"></p></section><section id="step-1-set-and-lock-pred"><h2>Step 1: Set and Lock <code>pred</code>
</h2>
<p><img src="/assets/img/concurrent-lists/fine-list.png" alt="" width="100%"></p></section><section id="step-2-hand-over-hand-locking"><h2>Step 2: Hand over Hand Locking</h2>
<p><img src="/assets/img/concurrent-lists/fine-list.png" alt="" width="100%"></p></section><section id="step-3-perform-insert"><h2>Step 3: Perform Insert</h2>
<p><img src="/assets/img/concurrent-lists/fine-list.png" alt="" width="100%"></p></section><section id="step-4-release-locks"><h2>Step 4: Release Locks</h2>
<p><img src="/assets/img/concurrent-lists/fine-list.png" alt="" width="100%"></p></section><section id="test"><h2>Test</h2>
<ul>
  <li>More efficient than coarse?</li>
</ul>
<div style="margin-bottom: 4em"></div>
<ul>
  <li>Why or why not?</li>
</ul>
<div style="margin-bottom: 4em"></div>
<ul>
  <li>What affects performance?</li>
</ul>
<div style="margin-bottom: 4em"></div></section><section id="optimistic-linked-list"><h1>Optimistic Linked List</h1></section><section id="optimistic-linked-list-1"><h2>Optimistic Linked List</h2>
<p>One lock per node</p>
<p>For any operation:</p>
<ol>
  <li>Find location</li>
  <li>Acquire locks</li>
  <li>Validate location
    <ul>
      <li>go back to 1 if this fails!</li>
    </ul>
  </li>
  <li>Perform operation</li>
  <li>Release locks</li>
</ol></section><section id="optimistic-list-figure"><h2>Optimistic List Figure</h2>
<p><img src="/assets/img/concurrent-lists/optimistic-list.png" alt="" width="100%"></p></section><section id="add-item-with-key-5-2"><h2>Add <code>item</code> with Key <code>5</code>
</h2>
<p><img src="/assets/img/concurrent-lists/optimistic-list.png" alt="" width="100%"></p></section><section id="step-1-find-location"><h2>Step 1: Find Location</h2>
<p><img src="/assets/img/concurrent-lists/optimistic-list.png" alt="" width="100%"></p></section><section id="step-2-acquire-locks"><h2>Step 2: Acquire Locks</h2>
<p><img src="/assets/img/concurrent-lists/optimistic-list.png" alt="" width="100%"></p></section><section id="step-3-validate"><h2>Step 3: Validate</h2>
<p><img src="/assets/img/concurrent-lists/optimistic-list.png" alt="" width="100%"></p></section><section id="step-4-perform-operation"><h2>Step 4: Perform Operation</h2>
<p><img src="/assets/img/concurrent-lists/optimistic-list.png" alt="" width="100%"></p></section><section id="step-5-release-locks"><h2>Step 5: Release Locks</h2>
<p><img src="/assets/img/concurrent-lists/optimistic-list.png" alt="" width="100%"></p></section><section id="why-could-validation-fail"><h2>Why Could Validation fail?</h2>
<p><img src="/assets/img/concurrent-lists/optimistic-list.png" alt="" width="100%"></p></section><section id="questions"><h2>Questions</h2>
<ul>
  <li>Liveness: Deadlock-free? Starvation-free?</li>
</ul>
<div style="margin-bottom: 6em"></div>
<ul>
  <li>Performance: When do you expect good performance? When not?</li>
</ul>
<div style="margin-bottom: 6em"></div></section><section id="next-time"><h2>Next Time:</h2>
<ol>
  <li>Lazy Synchronized List</li>
  <li>Nonblocking Synchronized List</li>
  <li>Other Data Structures</li>
</ol></section>
</div></div>


	  <script src="/assets/reveal.js-master/dist/reveal.js"></script>
	  <script src="/assets/reveal.js-master/plugin/math/math.js"></script>
	  <script src="/assets/reveal.js-master/plugin/zoom/zoom.js"></script>
	  <script src="/assets/reveal.js-master/plugin/notes/notes.js"></script>
	  <script src="/assets/reveal.js-master/plugin/search/search.js"></script>
	  <script src="/assets/reveal.js-master/plugin/markdown/markdown.js"></script>
	  <script src="/assets/reveal.js-master/plugin/highlight/highlight.js"></script>
	  <script>
	    

	    // Also available as an ES module, see:
	    // https://revealjs.com/initialization/
	    Reveal.initialize({
		controls: false,
		progress: true,
		center: true,
		hash: true,
		transition: 'none',
		math: {
		    config: 'TeX-AMS_HTML-full',
		    TeX: {
			Macros: {
			    R: '\\mathbb{R}',
			    set: [ '\\left\\{#1 \\; ; \\; #2\\right\\}', 2 ]
			}
		    }
		},


		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight, RevealMath ]
	    });

	  </script>

	</body>
</html>
	  

<!-- <\!-- load the reveal.js css & js (assuming you've put it in assets/)-\-> -->
<!-- <link -->
<!--   rel="stylesheet" -->
<!--   href="/assets/reveal.js-master/css/reveal.scss" -->
<!-- /> -->
<!-- <link -->
<!--   rel="stylesheet" -->
<!--   href="/assets/reveal.js-master/css/theme/source/white.scss" -->
<!-- /> -->
<!-- <script -->
<!--   src="/assets/reveal.js-master/js/reveal.js" -->
<!--   type="text/javascript" -->
<!-- ></script> -->

<!-- <\!-- configure the presentation, (you can tweak options to suit) -\-> -->
<!-- <script> -->
<!--   Reveal.initialize({ -->
<!--     // Display presentation control arrows -->
<!--     controls: false, -->

<!--     // Help the user learn the controls by providing hints, for example by -->
<!--     // bouncing the down arrow when they first encounter a vertical slide -->
<!--     controlsTutorial: false, -->

<!--     // Determines where controls appear, "edges" or "bottom-right" -->
<!--     controlsLayout: "bottom-right", -->

<!--     // Visibility rule for backwards navigation arrows; "faded", "hidden" -->
<!--     // or "visible" -->
<!--     controlsBackArrows: "faded", -->

<!--     // Display a presentation progress bar -->
<!--     progress: true, -->

<!--     // Display the page number of the current slide -->
<!--     slideNumber: false, -->

<!--     // Push each slide change to the browser history -->
<!--     history: false, -->

<!--     // Enable keyboard shortcuts for navigation -->
<!--     keyboard: true, -->

<!--     // Enable the slide overview mode -->
<!--     overview: true -->
<!--   }); -->
<!-- </script> -->
