<!doctype html>
<html lang="en">
	<head>

	  <meta name="viewport" content="width=device-width, initial-scale=1.0">
	  <meta charset="utf-8">

		<link rel="stylesheet" href="/assets/reveal.js-master/dist/reset.css">
		<link rel="stylesheet" href="/assets/reveal.js-master/dist/reveal.css">
		<link rel="stylesheet" href="/assets/css/condensation.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="/assets/reveal.js-master/plugin/highlight/monokai.css" id="highlight-theme">
		<link href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700" rel="stylesheet">

	</head>

	<body>


	  <!-- this is where the reveailfy filter gets applied -->
	  <div class="reveal"><div class="slides">


































































<!-- ## High Level Strategy -->

<!-- - explore until we reach the goal! -->
<!-- - keep track of where we’ve been so we don’t repeat cells -->

<!-- ## In More Detail -->

<!-- - fix an order on possible neighbors of cells -->
<!--     - e.g., north, east, south west -->
<!-- - when visiting a cell: -->
<!--     - mark it as visited -->
<!--     - check if it is the goal -->
<!--     - if not, visit “next” unvisited neighbor -->
<!--     - if no unvisited neighbors, return to “parent” cell -->

<!-- ## Representing a Maze in Code -->

<!-- - `Cell` class stores (among other things) -->
<!--     - list of references to neighboring `Cell`s (those not separated by walls) -->
<!-- - `Maze` class stores -->
<!--     - 2d array of `Cell`s -->
<!--     - `start` and `goal` cells -->

<!-- ## Implementing Our Solution Strategy -->

<!-- - use an `ArrayList` to keep track of `visited` cells -->
<!-- - use a stack to keep track of `active`  cells -->
<!--     - `active` cells form a path from `start` to current cell -->
<!--     - when we visit a new cell, push it to the stack -->
<!--     - when we’ve explored all neighbors (and haven’t found the goal): -->
<!--         - pop current cell off stack -->
<!--         - return to previous cell on stack—cell from which we initially visited current cell -->

<!-- ## Illustration -->

<!-- ![](/assets/img/mazes/maze02.png){: width="30%"} -->

<!-- <div style="margin-bottom: 6em"></div> -->

<!-- ## Recursion: Our Old Friend -->

<!-- Use a stack an find goal recursively -->

<!-- - write method `boolean solve (Stack<Cell> active, ArrayList<Cell> visited) {...}` -->

<!-- How? -->

<!-- ## Stack-based solution -->

<!-- - idea: try to find `goal` from `current` cell (top of `active`) -->
<!--     - if `current` is `goal`, return `true` -->
<!--     - otherwise, find `goal` from unvisited neighbors: -->
<!--         - push neighbor onto `active` stack and add neighbor to `visited` -->
<!--         - call `solve` to continue exploration from new neighbor -->
<!--     - if recursive call to `solve` returns `true`, we should return `true` too -->
<!--     - if exploration fails to find anything pop `current` off stack and return `false` -->

<!-- When `goal` is found, `active` will contain the path from `start` to `goal` 	 -->

<!-- ## Solution in Code -->

<!-- ## Question -->

<!-- Some of our solutions were really inefficient! -->

<!-- - goal could be adjacent to start, but a much longer path from start to goal is found -->

<!-- How could we ensure that we find the shortest path from start to goal? -->

<!-- ## Another Strategy -->

<!-- Explore in all directions simultaneously! -->
<section id="lecture-23-josephus-and-mazes"><h1>Lecture 23: Josephus and Mazes</h1></section><section id="overview"><h2>Overview</h2>
<ol>
  <li>Josephus Problem</li>
  <li>Solving Mazes</li>
</ol></section><section id="last-time"><h2>Last Time</h2>
<ol>
  <li>Queue ADT
    <ul>
      <li>enqueue/dequeue operations</li>
      <li>FIFO (first-in, first-out)</li>
    </ul>
  </li>
  <li>Josephus Problem</li>
</ol></section><section id="josephus-manicure-problem"><h2>Josephus’ Manicure Problem</h2>
<ul>
  <li>$n$ people determine to give each other manicures</li>
  <li>they only have 1 set of tools/supplies
    <ul>
      <li>only one person can give another a manicure at a time</li>
    </ul>
  </li>
  <li>once a person receives a manicure, they leave</li>
</ul>
<p>Setup:</p>
<ul>
  <li>people seated at a round table</li>
  <li>labeled sequentially clock-wise from $1$ to $n$</li>
</ul></section><section id="a-system"><h2>A System</h2>
<ul>
  <li>the current manicurist gives a manicure to the person seated to their left</li>
  <li>after the manicure, person to their left leaves</li>
  <li>the manicurist hands the tools to the next person to their left who becomes the next manicurist</li>
  <li>repeat until all but one person receives a manicure</li>
</ul>
<p>Initially, person 1 is manicurist.</p></section><section id="example-n--5"><h2>Example $n = 5$</h2>
<p><img src="/assets/img/josephus/josephus-5.png" alt="" width="100%"></p></section><section id="an-activity"><h2>An Activity</h2>
<ul>
  <li>
    <p>Devise a procedure for determining where Josephus should sit to avoid a manicure</p>
  </li>
  <li>
    <p>Use a queue!</p>
    <ul>
      <li>assume your queue has a <code>getSize()</code> method</li>
    </ul>
  </li>
</ul></section><section id="how-can-we-find-josephus-spot"><h2>How Can We Find Josephus’ Spot?</h2>
<div style="margin-bottom: 18em"></div></section><section id="proposed-queue-solution"><h2>Proposed Queue Solution</h2>
<ol>
  <li>Add people 1 through n to a queue in order
    <ul>
      <li>head of queue is manicurist</li>
      <li>person behind them receives manicure</li>
    </ul>
  </li>
  <li>Repeat until queue has size 1:
    <ol>
      <li>dequeue manicurist</li>
      <li>enqueue manicurist</li>
      <li>dequeue receiver of manicure</li>
    </ol>
  </li>
</ol>
<div style="margin-bottom: 8em"></div></section><section id="code-up-a-solution"><h2>Code Up a Solution!</h2></section><section id="mazes"><h1>Mazes</h1>
<p>What is a Maze?</p>
<ul>
  <li>a grid of cells</li>
  <li>each cell has up to 4 neighboring cells
    <ul>
      <li>some adjacent cells blocked off by walls</li>
    </ul>
  </li>
  <li>specified starting cell and goal cell</li>
</ul>
<p><strong>Objective</strong> find a path from starting cell to goal cell</p></section><section id="maze-example"><h2>Maze Example</h2>
<p><img src="/assets/img/mazes/maze01.png" alt="" width="50%"></p></section><section id="an-activity-1"><h2>An Activity</h2>
<p>How can we solve mazes in general?</p>
<ul>
  <li>Come up with a procedure that will always find a solution to a maze</li>
  <li>No code</li>
</ul></section><section id="maze-example-1"><h2>Maze Example</h2>
<p><img src="/assets/img/mazes/maze01.png" alt="" width="50%"></p></section>
</div></div>


	  <script src="/assets/reveal.js-master/dist/reveal.js"></script>
	  <script src="/assets/reveal.js-master/plugin/math/math.js"></script>
	  <script src="/assets/reveal.js-master/plugin/zoom/zoom.js"></script>
	  <script src="/assets/reveal.js-master/plugin/notes/notes.js"></script>
	  <script src="/assets/reveal.js-master/plugin/search/search.js"></script>
	  <script src="/assets/reveal.js-master/plugin/markdown/markdown.js"></script>
	  <script src="/assets/reveal.js-master/plugin/highlight/highlight.js"></script>
	  <script>
	    

	    // Also available as an ES module, see:
	    // https://revealjs.com/initialization/
	    Reveal.initialize({
		controls: false,
		progress: true,
		center: true,
		hash: true,
		transition: 'none',
		math: {
		    config: 'TeX-AMS_HTML-full',
		    TeX: {
			Macros: {
			    R: '\\mathbb{R}',
			    set: [ '\\left\\{#1 \\; ; \\; #2\\right\\}', 2 ]
			}
		    }
		},


		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight, RevealMath ]
	    });

	  </script>

	</body>
</html>
	  

<!-- <\!-- load the reveal.js css & js (assuming you've put it in assets/)-\-> -->
<!-- <link -->
<!--   rel="stylesheet" -->
<!--   href="/assets/reveal.js-master/css/reveal.scss" -->
<!-- /> -->
<!-- <link -->
<!--   rel="stylesheet" -->
<!--   href="/assets/reveal.js-master/css/theme/source/white.scss" -->
<!-- /> -->
<!-- <script -->
<!--   src="/assets/reveal.js-master/js/reveal.js" -->
<!--   type="text/javascript" -->
<!-- ></script> -->

<!-- <\!-- configure the presentation, (you can tweak options to suit) -\-> -->
<!-- <script> -->
<!--   Reveal.initialize({ -->
<!--     // Display presentation control arrows -->
<!--     controls: false, -->

<!--     // Help the user learn the controls by providing hints, for example by -->
<!--     // bouncing the down arrow when they first encounter a vertical slide -->
<!--     controlsTutorial: false, -->

<!--     // Determines where controls appear, "edges" or "bottom-right" -->
<!--     controlsLayout: "bottom-right", -->

<!--     // Visibility rule for backwards navigation arrows; "faded", "hidden" -->
<!--     // or "visible" -->
<!--     controlsBackArrows: "faded", -->

<!--     // Display a presentation progress bar -->
<!--     progress: true, -->

<!--     // Display the page number of the current slide -->
<!--     slideNumber: false, -->

<!--     // Push each slide change to the browser history -->
<!--     history: false, -->

<!--     // Enable keyboard shortcuts for navigation -->
<!--     keyboard: true, -->

<!--     // Enable the slide overview mode -->
<!--     overview: true -->
<!--   }); -->
<!-- </script> -->
