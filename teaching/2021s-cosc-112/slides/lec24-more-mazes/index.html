<!doctype html>
<html lang="en">
	<head>

	  <meta name="viewport" content="width=device-width, initial-scale=1.0">
	  <meta charset="utf-8">

		<link rel="stylesheet" href="/assets/reveal.js-master/dist/reset.css">
		<link rel="stylesheet" href="/assets/reveal.js-master/dist/reveal.css">
		<link rel="stylesheet" href="/assets/css/condensation.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="/assets/reveal.js-master/plugin/highlight/monokai.css" id="highlight-theme">
		<link href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700" rel="stylesheet">

	</head>

	<body>


	  <!-- this is where the reveailfy filter gets applied -->
	  <div class="reveal"><div class="slides">































































































































<section id="lecture-24-more-mazes"><h1>Lecture 24: More Mazes</h1></section><section id="last-time"><h2>Last Time</h2>
<p><img src="/assets/img/mazes/maze01.png" alt="" width="50%"></p></section><section id="how-can-we-solve-mazes"><h2>How Can We Solve Mazes?</h2>
<p>Suggested strategy:</p>
<ul>
  <li>Store visited cells</li>
  <li>Pick a direction, and go until dead end
    <ul>
      <li>walled in, or have already visited neighbors</li>
    </ul>
  </li>
  <li>Backtrack until you see an unvisited neighboring node</li>
  <li>Continue in new direction</li>
</ul>
<p>This strategy is <strong>depth-first</strong></p>
<ul>
  <li>Go as far as possible and backtrack</li>
</ul></section><section id="strategy-illustrated"><h2>Strategy Illustrated</h2>
<p><img src="/assets/img/mazes/maze01.png" alt="" width="50%"></p></section><section id="in-more-detail"><h2>In More Detail</h2>
<ul>
  <li>fix an order on possible neighbors of cells
    <ul>
      <li>e.g., right, down, left, up</li>
    </ul>
  </li>
  <li>when visiting a cell:
    <ul>
      <li>mark it as visited</li>
      <li>check if it is the goal</li>
      <li>if not, visit “next” unvisited neighbor</li>
      <li>if no unvisited neighbors, return to “parent” cell</li>
    </ul>
  </li>
</ul></section><section id="representing-a-maze-in-code"><h2>Representing a Maze in Code</h2>
<ul>
  <li>
<code>Cell</code> class stores (among other things)
    <ul>
      <li>list of references to neighboring <code>Cell</code>s (those not separated by walls)</li>
    </ul>
  </li>
  <li>
<code>Maze</code> class stores
    <ul>
      <li>2d array of <code>Cell</code>s</li>
      <li>
<code>start</code> and <code>goal</code> cells</li>
    </ul>
  </li>
</ul></section><section id="how-to-implement-solution"><h2>How to Implement Solution?</h2>
<ul>
  <li>Store <code>visited</code> cells (How?)</li>
  <li>Store <code>active</code> cells (How?)
    <ul>
      <li>not yet exhausted</li>
      <li>forms path back to <code>start</code>
</li>
    </ul>
  </li>
</ul>
<p><img src="/assets/img/mazes/maze01.png" alt="" width="25%"></p>
<div style="margin-bottom: 4em"></div></section><section id="implementing-our-solution-strategy"><h2>Implementing Our Solution Strategy</h2>
<ul>
  <li>use an <code>ArrayList</code> to keep track of <code>visited</code> cells</li>
  <li>use a <strong>stack</strong> to keep track of <code>active</code>  cells
    <ul>
      <li>
<code>active</code> cells form a path from <code>start</code> to current cell</li>
      <li>when we visit a new cell, push it to the stack</li>
      <li>when we’ve explored all neighbors (and haven’t found the goal):
        <ul>
          <li>pop current cell off stack</li>
          <li>return to previous cell on stack—cell from which we initially visited current cell</li>
        </ul>
      </li>
    </ul>
  </li>
</ul></section><section id="illustration"><h2>Illustration</h2>
<p><img src="/assets/img/mazes/maze02.png" alt="" width="30%"></p>
<div style="margin-bottom: 6em"></div></section><section id="recursion-our-old-friend"><h2>Recursion: Our Old Friend</h2>
<p>Use a stack an find goal recursively</p>
<ul>
  <li>write method <code>boolean solve (Stack&lt;Cell&gt; active, ArrayList&lt;Cell&gt; visited) {...}</code>
</li>
</ul>
<p>How?</p></section><section id="stack-based-solution"><h2>Stack-based solution</h2>
<ul>
  <li>idea: try to find <code>goal</code> from <code>current</code> cell (top of <code>active</code>)
    <ul>
      <li>if <code>current</code> is <code>goal</code>, return <code>true</code>
</li>
      <li>otherwise, find <code>goal</code> from unvisited neighbors:
        <ul>
          <li>push neighbor onto <code>active</code> stack and add neighbor to <code>visited</code>
</li>
          <li>call <code>solve</code> to continue exploration from new neighbor</li>
        </ul>
      </li>
      <li>if recursive call to <code>solve</code> returns <code>true</code>, we should return <code>true</code> too</li>
      <li>if exploration fails to find anything pop <code>current</code> off stack and return <code>false</code>
</li>
    </ul>
  </li>
</ul>
<p>When <code>goal</code> is found, <code>active</code> will contain the path from <code>start</code> to <code>goal</code></p></section><section id="solution-in-code"><h2>Solution in Code</h2></section><section id="question"><h2>Question</h2>
<p>Some of our solutions were really inefficient!</p>
<ul>
  <li>goal could be adjacent to start, but a much longer path from start to goal is found</li>
</ul>
<p>How could we ensure that we find the shortest path from start to goal?</p></section><section id="another-strategy"><h2>Another Strategy</h2>
<p>Explore in all directions simultaneously!</p>
<ul>
  <li>Consider all possible first steps</li>
  <li>Then all possible second steps
    <ul>
      <li>ignore previously visited cells</li>
    </ul>
  </li>
  <li>…</li>
</ul>
<p>This strategy is <strong>breadth first</strong></p>
<ul>
  <li>Explore all possible next steps</li>
</ul></section><section id="illustration-depth-1"><h2>Illustration: Depth 1</h2>
<p><img src="/assets/img/mazes/bfs1.png" alt="" width="50%"></p></section><section id="illustration-depth-2"><h2>Illustration: Depth 2</h2>
<p><img src="/assets/img/mazes/bfs2.png" alt="" width="50%"></p></section><section id="illustration-depth-3"><h2>Illustration: Depth 3</h2>
<p><img src="/assets/img/mazes/bfs3.png" alt="" width="50%"></p></section><section id="illustration-depth-4"><h2>Illustration: Depth 4</h2>
<p><img src="/assets/img/mazes/bfs4.png" alt="" width="50%"></p></section><section id="completed-search"><h2>Completed Search</h2>
<p><img src="/assets/img/mazes/bfs5.png" alt="" width="50%"></p></section><section id="return-solution"><h2>Return Solution</h2>
<p><img src="/assets/img/mazes/bfs6.png" alt="" width="50%"></p></section><section id="a-nice-feature"><h2>A Nice Feature</h2>
<p>The shortest path from start to goal is found</p>
<ul>
  <li>why?</li>
</ul>
<div style="margin-bottom: 12em"></div></section><section id="implementation-notes"><h2>Implementation Notes</h2>
<ul>
  <li>again, store <code>visited</code> and <code>active</code>
</li>
  <li>
<code>active</code> cells are boundary between <code>visited</code> and unvisited</li>
  <li>store <code>active</code> cells in a <strong>queue</strong>
    <ul>
      <li>all cells at distance $d$ from start are visited before any cell at distance $d+1$ is visited</li>
    </ul>
  </li>
  <li>initially, <code>active</code> and <code>visited</code> are just starting cell</li>
  <li>each cell stores its <code>parent</code> cell
    <ul>
      <li>
<code>parent</code> is cell from which cell was visited</li>
    </ul>
  </li>
</ul></section><section id="breadth-first-illustration"><h2>Breadth-first Illustration</h2>
<p><img src="/assets/img/mazes/maze02.png" alt="" width="30%"></p>
<div style="margin-bottom: 6em"></div></section><section id="breadth-first-in-code"><h2>Breadth-first in Code</h2></section><section id="two-solution-philosophies"><h2>Two Solution Philosophies</h2>
<ol>
  <li>Depth-first
    <ul>
      <li>Keep going until you can’t go any farther, then backtrack</li>
      <li>Naturally suited to stack ADT</li>
      <li>Naturally suited to recursive solution</li>
    </ul>
  </li>
  <li>Breadth-first
    <ul>
      <li>Exhaustively search all cells in increasing</li>
    </ul>
  </li>
</ol></section>
</div></div>


	  <script src="/assets/reveal.js-master/dist/reveal.js"></script>
	  <script src="/assets/reveal.js-master/plugin/math/math.js"></script>
	  <script src="/assets/reveal.js-master/plugin/zoom/zoom.js"></script>
	  <script src="/assets/reveal.js-master/plugin/notes/notes.js"></script>
	  <script src="/assets/reveal.js-master/plugin/search/search.js"></script>
	  <script src="/assets/reveal.js-master/plugin/markdown/markdown.js"></script>
	  <script src="/assets/reveal.js-master/plugin/highlight/highlight.js"></script>
	  <script>
	    

	    // Also available as an ES module, see:
	    // https://revealjs.com/initialization/
	    Reveal.initialize({
		controls: false,
		progress: true,
		center: true,
		hash: true,
		transition: 'none',
		math: {
		    config: 'TeX-AMS_HTML-full',
		    TeX: {
			Macros: {
			    R: '\\mathbb{R}',
			    set: [ '\\left\\{#1 \\; ; \\; #2\\right\\}', 2 ]
			}
		    }
		},


		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight, RevealMath ]
	    });

	  </script>

	</body>
</html>
	  

<!-- <\!-- load the reveal.js css & js (assuming you've put it in assets/)-\-> -->
<!-- <link -->
<!--   rel="stylesheet" -->
<!--   href="/assets/reveal.js-master/css/reveal.scss" -->
<!-- /> -->
<!-- <link -->
<!--   rel="stylesheet" -->
<!--   href="/assets/reveal.js-master/css/theme/source/white.scss" -->
<!-- /> -->
<!-- <script -->
<!--   src="/assets/reveal.js-master/js/reveal.js" -->
<!--   type="text/javascript" -->
<!-- ></script> -->

<!-- <\!-- configure the presentation, (you can tweak options to suit) -\-> -->
<!-- <script> -->
<!--   Reveal.initialize({ -->
<!--     // Display presentation control arrows -->
<!--     controls: false, -->

<!--     // Help the user learn the controls by providing hints, for example by -->
<!--     // bouncing the down arrow when they first encounter a vertical slide -->
<!--     controlsTutorial: false, -->

<!--     // Determines where controls appear, "edges" or "bottom-right" -->
<!--     controlsLayout: "bottom-right", -->

<!--     // Visibility rule for backwards navigation arrows; "faded", "hidden" -->
<!--     // or "visible" -->
<!--     controlsBackArrows: "faded", -->

<!--     // Display a presentation progress bar -->
<!--     progress: true, -->

<!--     // Display the page number of the current slide -->
<!--     slideNumber: false, -->

<!--     // Push each slide change to the browser history -->
<!--     history: false, -->

<!--     // Enable keyboard shortcuts for navigation -->
<!--     keyboard: true, -->

<!--     // Enable the slide overview mode -->
<!--     overview: true -->
<!--   }); -->
<!-- </script> -->
